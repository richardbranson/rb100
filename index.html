<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RB100 30-Minute Workout</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #050b16;
      --panel: rgba(12, 20, 37, 0.85);
      --panel-strong: rgba(16, 28, 52, 0.92);
      --outline: rgba(255, 255, 255, 0.08);
      --text: #f4f6fb;
      --muted: rgba(244, 246, 251, 0.64);
      --accent: #4f7bff;
      --accent-soft: rgba(79, 123, 255, 0.22);
      --success: #4fd1c5;
      --phase-prepare: #f6c65c;
      --phase-work: #32d27c;
      --phase-rest: #ff6b6b;
      --phase-cycle: #7f93ff;
      --phase-paused: #f6c65c;
      --phase-track: rgba(255, 255, 255, 0.12);
      font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at 30% -10%, rgba(79, 123, 255, 0.2), transparent 55%),
        radial-gradient(circle at 80% 120%, rgba(79, 123, 255, 0.18), transparent 50%),
        var(--bg);
      color: var(--text);
      overflow: hidden;
    }

    .app-shell {
      position: relative;
      height: min(100vh, 3840px);
      aspect-ratio: 9 / 16;
      width: min(100vw, calc(min(100vh, 3840px) * 9 / 16));
      max-width: 1400px;
      border-radius: 32px;
      background: rgba(7, 12, 25, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 32px 68px rgba(0, 0, 0, 0.55);
      display: grid;
      grid-template-rows: auto 1fr auto;
      overflow: hidden;
      backdrop-filter: blur(24px);
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: clamp(20px, 2.5vh, 42px) clamp(28px, 3vw, 56px);
      background: linear-gradient(135deg, rgba(79, 123, 255, 0.25), rgba(79, 123, 255, 0));
      border-bottom: 1px solid var(--outline);
      gap: clamp(20px, 2vw, 36px);
    }

    .branding h1 {
      margin: 0;
      font-size: clamp(2rem, 2.2vw, 2.4rem);
      letter-spacing: 0.22em;
      text-transform: uppercase;
    }

    .branding span {
      display: block;
      margin-top: 0.25rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      font-size: clamp(1rem, 1vw, 0.9rem);
      color: var(--muted);
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: clamp(16px, 2vw, 28px);
    }

    .current-time {
      font-size: clamp(2rem, 1.2vw, 1.3rem);
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: var(--muted);
      min-width: 4ch;
      text-align: right;
    }

    .config-toggle {
      border: 1px solid rgba(255, 255, 255, 0.16);
      background: rgba(8, 15, 32, 0.7);
      color: inherit;
      font-size: clamp(0.85rem, 1vw, 1rem);
      letter-spacing: 0.15em;
      text-transform: uppercase;
      padding: 0.7em 1.4em;
      border-radius: 999px;
      display: flex;
      align-items: center;
      gap: 0.6em;
      cursor: pointer;
      transition: transform 160ms ease, background 160ms ease;
    }

    .config-toggle:hover,
    .config-toggle:focus-visible {
      transform: translateY(-2px);
      background: rgba(16, 26, 48, 0.95);
      outline: none;
    }

    main {
      display: grid;
      grid-template-columns: 1fr;
      grid-template-rows: 1fr auto;
      padding: clamp(24px, 3vh, 48px) clamp(28px, 3vw, 56px);
      gap: clamp(24px, 3vh, 44px);
    }

    .timer-section {
      display: grid;
      grid-template-rows: auto auto;
      gap: clamp(18px, 2.5vh, 28px);
    }

    .main-timer {
      display: grid;
      grid-template-columns: minmax(0, 1fr);
      justify-items: center;
      gap: clamp(16px, 2.5vh, 24px);
    }

    .timer-ring {
      position: relative;
      width: clamp(320px, 45vw, 520px);
      aspect-ratio: 1 / 1;
    }

    .timer-progress {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      display: grid;
      place-items: center;
      padding: clamp(18px, 2vw, 30px);
      transition: filter 180ms ease;
      pointer-events: none;
    }

    .timer-progress::after {
      content: "";
      position: absolute;
      inset: clamp(32px, 4vw, 48px);
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(5, 10, 20, 0.85);
    }

    .timer-svg {
      position: absolute;
      inset: clamp(18px, 2vw, 30px);
      width: auto;
      height: auto;
      overflow: visible;
    }

    .timer-svg circle {
      fill: none;
      stroke-linecap: round;
      stroke-width: clamp(12px, 1.6vw, 18px);
      transform: rotate(-90deg);
      transform-origin: 50% 50%;
    }

    .timer-track {
      stroke: rgba(255, 255, 255, 0.08);
    }

    .timer-arc {
      stroke-dasharray: 0 999;
      stroke-dashoffset: 0;
      opacity: 0;
      transition: opacity 200ms ease, stroke 160ms ease, stroke-dashoffset 120ms linear;
    }

    .timer-arc--work {
      stroke: var(--phase-work);
    }

    .timer-arc--rest {
      stroke: var(--phase-rest);
    }

    .timer-arc--elapsed {
      stroke: rgba(255, 255, 255, 0.24);
      opacity: 1;
    }

    .timer-ring[data-phase="prepare"] .timer-arc--work {
      stroke: var(--phase-prepare);
    }

    .timer-ring[data-phase="paused"] .timer-arc--work,
    .timer-ring[data-phase="paused"] .timer-arc--rest {
      stroke: var(--phase-paused);
    }

    .timer-ring[data-phase="cycleRest"] .timer-arc--rest {
      stroke: var(--phase-cycle);
    }

    .timer-ring[data-phase="rest"] .timer-arc--rest {
      stroke: var(--phase-rest);
    }

    .timer-ring[data-phase="work"] .timer-arc--work {
      stroke: var(--phase-work);
    }

    .timer-inner {
      position: relative;
      z-index: 1;
      text-align: center;
      display: grid;
      gap: 0.35rem;
    }

    .timer-label {
      font-size: clamp(0.85rem, 1.1vw, 1.1rem);
      letter-spacing: 0.3em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .timer-value {
      font-size: clamp(3rem, 6vw, 4.4rem);
      font-weight: 700;
      letter-spacing: 0.18em;
    }

    .phase-indicator {
      font-size: clamp(1.05rem, 1.6vw, 1.5rem);
      letter-spacing: 0.28em;
      text-transform: uppercase;
      color: var(--accent);
    }

    .mini-progress-grid {
      display: grid;
      grid-template-columns: repeat(2, clamp(130px, 18vw, 180px));
      gap: clamp(12px, 2vw, 32px);
      justify-content: center;
    }

    .mini-progress {
      position: relative;
      border-radius: 50%;
      aspect-ratio: 1 / 1;
      --angle: 0deg;
      background:
        radial-gradient(circle at center, rgba(12, 18, 34, 0.9) 0 60%, transparent 60%),
        conic-gradient(var(--success) var(--angle), rgba(255, 255, 255, 0.08) var(--angle));
      display: grid;
      place-items: center;
      padding: clamp(12px, 1.4vw, 18px);
      border: 1px solid rgba(255, 255, 255, 0.12);
    }

    .mini-progress strong {
      font-size: clamp(1.4rem, 2.5vw, 1.9rem);
      letter-spacing: 0.12em;
    }

    .mini-progress span {
      font-size: clamp(0.7rem, 1vw, 0.9rem);
      letter-spacing: 0.22em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .segment-summary {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: clamp(16px, 2vw, 32px);
      padding: clamp(18px, 2vh, 28px);
      background: var(--panel-strong);
      border-radius: 22px;
      border: 1px solid var(--outline);
    }

    .segment-card {
      display: grid;
      gap: 0.35rem;
    }

    .segment-card span {
      letter-spacing: 0.3em;
      font-size: clamp(0.75rem, 1vw, 0.95rem);
      text-transform: uppercase;
      color: var(--muted);
    }

    .segment-card strong {
      font-size: clamp(1.3rem, 2.4vw, 2rem);
      letter-spacing: 0.16em;
    }

    .segment-card p {
      margin: 0;
      font-size: clamp(0.85rem, 1.1vw, 1.1rem);
      color: rgba(244, 246, 251, 0.75);
    }

    .segment-card .countdown {
      font-size: clamp(1rem, 2vw, 1.6rem);
      color: var(--accent);
      letter-spacing: 0.18em;
    }

    .segment-card .countdown::before {
      content: 'Total Remaining';
      display: block;
      font-size: clamp(0.7rem, 0.95vw, 0.85rem);
      letter-spacing: 0.26em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 0.35rem;
    }

    .exercise-section {
      display: grid;
      gap: clamp(14px, 2vh, 24px);
    }

    .exercise-section h2 {
      margin: 0;
      font-size: clamp(1.2rem, 1.8vw, 1.9rem);
      letter-spacing: 0.3em;
      text-transform: uppercase;
    }

    .exercise-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: clamp(14px, 1.6vw, 24px);
    }

    .exercise-card {
      background: var(--panel);
      border-radius: 20px;
      border: 1px solid var(--outline);
      padding: clamp(12px, 1.4vw, 18px);
      display: grid;
      gap: clamp(10px, 1vw, 14px);
      transition: transform 180ms ease, border 180ms ease, box-shadow 180ms ease;
    }

    .exercise-card.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(79, 123, 255, 0.25);
      transform: translateY(-4px);
    }

    .video-wrapper {
      width: 100%;
      aspect-ratio: 16 / 9;
      border-radius: 14px;
      overflow: hidden;
      background:
        radial-gradient(circle at 30% 30%, rgba(79, 123, 255, 0.45), rgba(79, 123, 255, 0.12)),
        rgba(12, 22, 44, 0.85);
      display: grid;
      place-items: center;
      position: relative;
    }

    .video-wrapper iframe,
    .video-wrapper video {
      width: 100%;
      height: 100%;
      display: block;
      border: 0;
    }

    .video-wrapper video {
      object-fit: cover;
      background: #000;
    }

    .video-placeholder {
      width: 100%;
      height: 100%;
      display: grid;
      place-items: center;
      font-size: clamp(0.75rem, 0.9vw, 0.95rem);
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.8);
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      clip-path: inset(50%);
      white-space: nowrap;
      border: 0;
    }

    .exercise-card h3 {
      margin: 0;
      font-size: clamp(0.95rem, 1.2vw, 1.25rem);
      letter-spacing: 0.08em;
    }

    .exercise-card p {
      margin: 0;
      font-size: clamp(0.75rem, 1vw, 0.95rem);
      color: rgba(244, 246, 251, 0.68);
      line-height: 1.4;
    }

    footer {
      border-top: 1px solid var(--outline);
      padding: clamp(20px, 2.3vh, 32px) clamp(28px, 3vw, 56px);
      display: grid;
      grid-template-columns: 2fr 1fr;
      align-items: center;
      gap: clamp(18px, 2vw, 28px);
      background: linear-gradient(0deg, rgba(10, 18, 36, 0.9), rgba(10, 18, 36, 0.6));
    }

    .control-group {
      display: grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap: clamp(10px, 1vw, 16px);
    }

    .control-group button {
      padding: clamp(12px, 1.4vw, 16px);
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(12, 20, 38, 0.85);
      color: inherit;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      font-size: clamp(0.7rem, 0.95vw, 0.95rem);
      cursor: pointer;
      transition: transform 150ms ease, background 150ms ease, border 150ms ease;
    }

    .control-group button:hover,
    .control-group button:focus-visible {
      transform: translateY(-2px);
      background: rgba(20, 32, 60, 0.95);
      border-color: var(--accent);
      outline: none;
    }

    .control-group button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
      border-color: rgba(255, 255, 255, 0.1);
    }

    .session-summary {
      justify-self: end;
      display: grid;
      gap: 0.35rem;
      text-align: right;
    }

    .session-summary span {
      font-size: clamp(0.7rem, 0.95vw, 0.9rem);
      letter-spacing: 0.26em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .session-summary strong {
      font-size: clamp(1.1rem, 1.6vw, 1.45rem);
      letter-spacing: 0.14em;
    }

    .config-panel {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      width: min(420px, 55%);
      background: rgba(7, 12, 24, 0.92);
      border-left: 1px solid var(--outline);
      box-shadow: -24px 0 48px rgba(0, 0, 0, 0.45);
      padding: clamp(24px, 3vh, 44px);
      display: grid;
      gap: clamp(18px, 2vh, 26px);
      transform: translateX(100%);
      transition: transform 220ms ease;
    }

    .config-panel[data-open="true"] {
      transform: translateX(0);
    }

    .config-panel header {
      padding: 0;
      border: none;
      background: none;
    }

    .config-panel h2 {
      margin: 0;
      font-size: 1.35rem;
      letter-spacing: 0.24em;
      text-transform: uppercase;
    }

    .config-panel form {
      display: grid;
      gap: clamp(16px, 1.8vh, 24px);
    }

    .field {
      display: grid;
      gap: 0.35rem;
    }

    .field label {
      font-size: 0.82rem;
      letter-spacing: 0.22em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .field input {
      width: 100%;
      padding: 0.75em 1em;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(10, 16, 30, 0.92);
      color: inherit;
      font-size: 1rem;
    }

    .config-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    .config-actions button {
      padding: 0.7em 1.4em;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(14, 22, 40, 0.88);
      color: inherit;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      cursor: pointer;
      transition: transform 160ms ease, background 160ms ease;
    }

    .config-actions button:hover,
    .config-actions button:focus-visible {
      transform: translateY(-2px);
      background: rgba(24, 36, 64, 0.95);
      border-color: var(--accent);
      outline: none;
    }

    .config-actions .accent {
      background: var(--accent);
      border-color: var(--accent);
      color: #050b16;
      font-weight: 600;
    }

    .config-actions .accent:hover,
    .config-actions .accent:focus-visible {
      background: #6c93ff;
    }

    @media (max-width: 900px) {
      .exercise-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      footer {
        grid-template-columns: 1fr;
        text-align: center;
      }

      .session-summary {
        justify-self: center;
        text-align: center;
      }

      .control-group {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }

    @media (max-width: 600px) {
      .exercise-grid {
        grid-template-columns: 1fr;
      }

      .mini-progress-grid {
        grid-template-columns: 1fr;
      }

      .config-panel {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <header>
      <div class="branding">
        <h1 id="workoutTitle">RB100 Workout</h1>
        <span id="workoutTagline">30 Minute Circuit</span>
      </div>
      <div class="header-actions">
        <div class="current-time" id="currentTimeDisplay" aria-live="polite">00:00</div>
        <button class="config-toggle" id="openConfig" type="button">⚙️ Configure</button>
      </div>
    </header>

    <main>
      <section class="timer-section">
        <div class="main-timer">
          <div class="timer-ring" id="timerRing" data-phase="prepare">
            <svg class="timer-svg" viewBox="0 0 120 120" aria-hidden="true">
              <circle class="timer-track" cx="60" cy="60" r="54" />
              <circle class="timer-arc timer-arc--rest" cx="60" cy="60" r="54" id="restArc" />
              <circle class="timer-arc timer-arc--work" cx="60" cy="60" r="54" id="workArc" />
              <circle class="timer-arc timer-arc--elapsed" cx="60" cy="60" r="54" id="activeArc" />
            </svg>
            <div class="timer-progress" id="totalProgress">
              <div class="timer-inner">
                <div class="timer-label" id="timerLabel">Prepare</div>
                <div class="timer-value" id="segmentTimeDisplay">00:10</div>
                <div class="phase-indicator" id="phaseIndicator">Get ready</div>
              </div>
            </div>
          </div>
          <div class="mini-progress-grid">
            <div class="mini-progress" id="roundProgress">
              <div class="timer-inner">
                <span>Round</span>
                <strong id="roundTracker">1 / 6</strong>
              </div>
            </div>
            <div class="mini-progress" id="cycleProgress">
              <div class="timer-inner">
                <span>Cycle</span>
                <strong id="cycleTracker">1 / 4</strong>
              </div>
            </div>
          </div>
        </div>
        <div class="segment-summary">
          <div class="segment-card">
            <span>Now</span>
            <strong id="currentAction">Prepare</strong>
            <p id="currentExercise">Dial in your form.</p>
            <div class="countdown" id="segmentCountdown">30:30</div>
          </div>
          <div class="segment-card">
            <span>Next</span>
            <strong id="nextAction">Work</strong>
            <p id="nextExercise">Kettlebell Swing is up first.</p>
          </div>
        </div>
      </section>

      <section class="exercise-section">
        <h2 id="exercisesHeading">6 Exercise Circuit</h2>
        <div class="exercise-grid" id="exerciseGrid"></div>
      </section>
    </main>

    <footer>
      <div class="control-group">
        <button id="prevExercise" type="button">⏮ Prev</button>
        <button id="startWorkout" type="button">Start</button>
        <button id="pauseWorkout" type="button">Pause</button>
        <button id="stopWorkout" type="button">Stop</button>
        <button id="resetWorkout" type="button">Reset</button>
        <button id="nextExercise" type="button">Next ⏭</button>
      </div>
      <div class="session-summary">
        <span>Session Progress</span>
        <strong id="summaryLabel">Round 1 · Cycle 1 · 30:30 left</strong>
      </div>
    </footer>

    <aside class="config-panel" id="configPanel" data-open="false">
      <header>
        <h2>Configuration</h2>
      </header>
      <form id="configForm">
        <div class="field">
          <label for="workoutSelect">Workout</label>
          <select id="workoutSelect" name="workout">
            <option value="rb100">RB100 Workout</option>
          </select>
        </div>
        <div class="field">
          <label for="musicSelect">Music</label>
          <select id="musicSelect" name="music">
            <option value="">Loading…</option>
          </select>
        </div>
        <div class="field">
          <label for="prepareDuration">Prepare (seconds)</label>
          <input type="number" id="prepareDuration" name="prepareDuration" min="0" value="10" />
        </div>
        <div class="field">
          <label for="rounds">Rounds</label>
          <input type="number" id="rounds" name="rounds" min="1" value="6" />
        </div>
        <div class="field">
          <label for="cycles">Cycles</label>
          <input type="number" id="cycles" name="cycles" min="1" value="4" />
        </div>
        <div class="field">
          <label for="workDuration">Work (seconds)</label>
          <input type="number" id="workDuration" name="workDuration" min="10" value="60" />
        </div>
        <div class="field">
          <label for="restRounds">Rest Between Rounds (seconds)</label>
          <input type="number" id="restRounds" name="restRounds" min="0" value="10" />
        </div>
        <div class="field">
          <label for="restCycles">Rest Between Cycles (seconds)</label>
          <input type="number" id="restCycles" name="restCycles" min="0" value="60" />
        </div>
      </form>
      <div class="config-actions">
        <button type="button" id="closeConfig">Close</button>
        <button type="button" class="accent" id="applyDefaults">Default Times</button>
      </div>
    </aside>
    <div id="musicPlayerHost" class="sr-only" aria-hidden="true"></div>
  </div>

  <script>
    (function () {
      const workoutsEndpoint = 'workouts.json';
      const fallbackWorkouts = [
        {
          slug: 'rb100',
          title: 'RB100 Workout',
          tagline: '30 Minute Circuit',
          exercisesHeading: '6 Exercise Circuit',
          summary: 'Signature kettlebell conditioning set.',
          settings: {
            prepareDuration: 10,
            totalRounds: 6,
            totalCycles: 4,
            workDuration: 60,
            restBetweenRounds: 10,
            restBetweenCycles: 60
          },
          audio: {
            music: 'focus-30'
          },
          exercises: [
            {
              name: 'Kettlebell Swing',
              description: 'Explosive hip hinge to power the bell overhead and ignite the posterior chain.',
              video: 'media/burpee_standard_v1.mp4'
            },
            {
              name: 'Push-Up to T Rotation',
              description: 'Alternate a side plank reach between each rep to build rotational stability.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=dSDoVEV2298',
                title: 'Push-Up to T Rotation demo'
              }
            },
            {
              name: 'Reverse Lunge & Press',
              description: 'Step back, drop the knee, and drive overhead with the opposite arm on return.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=ZPoMxOrIeO4'
              }
            },
            {
              name: 'Renegade Row',
              description: 'Brace through the core, row the bell, and resist trunk rotation under load.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=LccyTxiUrhg'
              }
            },
            {
              name: 'V-Up Reach',
              description: 'Snap to a V-sit while touching toes and controlling the eccentric descent.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=7UVgs18Y1P4'
              }
            },
            {
              name: 'Squat Thruster',
              description: 'Sink deep into a squat and explode into a powerful overhead drive.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=L219ltL15zk'
              }
            }
          ]
        },
        {
          slug: 'ignite-intervals',
          title: 'Ignite Intervals',
          tagline: '20 Minute Power Session',
          exercisesHeading: '4 Power Moves',
          summary: 'Short, sharp metabolic finisher.',
          settings: {
            prepareDuration: 20,
            totalRounds: 4,
            totalCycles: 3,
            workDuration: 45,
            restBetweenRounds: 15,
            restBetweenCycles: 75
          },
          audio: {
            music: 'focus-30'
          },
          exercises: [
            {
              name: 'Dumbbell Snatch',
              description: 'Drive through the hips and punch overhead for total-body power.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=0P7nlJLG4rg'
              }
            },
            {
              name: 'Box Jump Rebound',
              description: 'Explode onto the box, stick the landing, and rebound with athletic control.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=2fZCk_zYbzA'
              }
            },
            {
              name: 'Battle Rope Slams',
              description: 'Alternate heavy slams to spike the heart rate and challenge core stability.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=4FJ3eYJsaGI'
              }
            },
            {
              name: 'Assault Bike Sprint',
              description: 'Crank max effort through the pedals and handles for a brutal finisher.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=1jdr8mP7LPM'
              }
            }
          ]
        },
        {
          slug: 'mobility-reset',
          title: 'Mobility Reset',
          tagline: 'Low Impact Flow',
          exercisesHeading: '6 Mobility Drills',
          summary: 'Restore and lengthen with controlled tempo.',
          settings: {
            prepareDuration: 15,
            totalRounds: 6,
            totalCycles: 2,
            workDuration: 45,
            restBetweenRounds: 15,
            restBetweenCycles: 90
          },
          audio: {
            music: 'endurance-70'
          },
          exercises: [
            {
              name: 'World\'s Greatest Stretch',
              description: 'Flow between lunge, thoracic reach, and hamstring sweep to open the chain.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=XBqRr5nBKj8'
              }
            },
            {
              name: 'Thread the Needle',
              description: 'Mobilise the thoracic spine while keeping hips stacked and breathing steady.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=R5rHMyWyfKM'
              }
            },
            {
              name: 'Cossack Squat',
              description: 'Sink into lateral depth to unlock hips and ankles with control.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=_a7nK5E7EYE'
              }
            },
            {
              name: 'Dead Bug Reach',
              description: 'Brace the core while moving opposing limbs through controlled range.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=7Q1gRRtTDgY'
              }
            },
            {
              name: 'Prone Snow Angels',
              description: 'Sweep the arms overhead while squeezing the upper back and glutes.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=3jzCoqxKPlM'
              }
            },
            {
              name: '90/90 Switch',
              description: 'Rotate through internal and external hip rotation without leaning back.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=9-dg9zIIebw'
              }
            }
          ]
        }
      ];

      const fallbackAudioLibrary = {
        defaultMusic: 'focus-30',
        music: [
          {
            slug: 'focus-30',
            label: 'Focus Flow - 30 Minutes',
            type: 'youtube',
            url: 'https://www.youtube.com/watch?v=yScbNQYrR_A',
            duration: 1800
          },
          {
            slug: 'endurance-70',
            label: 'Endurance Builder - 70 Minutes',
            type: 'youtube',
            url: 'https://www.youtube.com/watch?v=neAGV0RMFV8',
            duration: 4200
          }
        ],
        prompts: {
          countdown: 'audio/RB_countdown.mp3',
          pause: 'audio/RB_pause.mp3',
          start: 'audio/RB_start.mp3',
          tenSecondsLeft: 'audio/RB_tenSecondsLeft.mp3',
          beeps: 'audio/RB_beeps.mp3',
          rest: 'audio/RB_rest.mp3',
          finished: 'audio/RB_finished.mp3'
        }
      };

      const defaultSettings = {
        prepareDuration: 10,
        totalRounds: 6,
        totalCycles: 4,
        workDuration: 60,
        restBetweenRounds: 10,
        restBetweenCycles: 60
      };

      const config = { ...defaultSettings };

      const state = {
        schedule: [],
        totalDuration: 0,
        currentSegmentIndex: 0,
        segmentRemaining: 0,
        totalRemaining: 0,
        isRunning: false,
        isPaused: false,
        animationFrame: null,
        lastTimestamp: null
      };

      const exerciseGrid = document.getElementById('exerciseGrid');
      const form = document.getElementById('configForm');
      const applyDefaultsBtn = document.getElementById('applyDefaults');
      const configPanel = document.getElementById('configPanel');
      const openConfigBtn = document.getElementById('openConfig');
      const closeConfigBtn = document.getElementById('closeConfig');
      const workoutSelect = document.getElementById('workoutSelect');
      const musicSelect = document.getElementById('musicSelect');

      const elements = {
        timerRing: document.getElementById('timerRing'),
        timerLabel: document.getElementById('timerLabel'),
        phaseIndicator: document.getElementById('phaseIndicator'),
        phaseTime: document.getElementById('segmentTimeDisplay'),
        roundProgress: document.getElementById('roundProgress'),
        cycleProgress: document.getElementById('cycleProgress'),
        roundTracker: document.getElementById('roundTracker'),
        cycleTracker: document.getElementById('cycleTracker'),
        currentAction: document.getElementById('currentAction'),
        currentExercise: document.getElementById('currentExercise'),
        nextAction: document.getElementById('nextAction'),
        nextExercise: document.getElementById('nextExercise'),
        segmentCountdown: document.getElementById('segmentCountdown'),
      summaryLabel: document.getElementById('summaryLabel'),
      cards: () => Array.from(document.querySelectorAll('.exercise-card')),
      workoutTitle: document.getElementById('workoutTitle'),
      workoutTagline: document.getElementById('workoutTagline'),
      exercisesHeading: document.getElementById('exercisesHeading'),
      currentTime: document.getElementById('currentTimeDisplay')
    };

      const controls = {
        start: document.getElementById('startWorkout'),
        pause: document.getElementById('pauseWorkout'),
        stop: document.getElementById('stopWorkout'),
        reset: document.getElementById('resetWorkout'),
        prev: document.getElementById('prevExercise'),
        next: document.getElementById('nextExercise')
      };

      const arcs = {
        work: document.getElementById('workArc'),
        rest: document.getElementById('restArc'),
        active: document.getElementById('activeArc')
      };

      const ARC_RADIUS = 54;
      const ARC_CIRCUMFERENCE = 2 * Math.PI * ARC_RADIUS;

      if (arcs.active) {
        arcs.active.style.strokeDasharray = `${ARC_CIRCUMFERENCE} ${ARC_CIRCUMFERENCE}`;
        arcs.active.style.strokeDashoffset = ARC_CIRCUMFERENCE;
      }

    let audioLibrary = {
      defaultMusic: null,
      music: [],
      prompts: {}
    };

    const promptSources = new Map();

    const audioState = {
      selectedMusicSlug: null,
      currentTrack: null,
      shouldPlay: false,
      isPlaying: false,
      pendingPlay: false,
      player: null,
      playerReady: false,
      duckTimeout: null,
      baseVolume: 55,
      duckVolume: 25,
      pendingTrackId: null,
      pendingAutoPlay: false
    };

    const youTubeState = {
      apiRequested: false,
      ready: false,
      resolveQueue: []
    };

    const promptState = {
      segmentKey: null,
      countdownPlayed: false,
      tenSecondPlayed: false,
      threeSecondPlayed: false,
      completed: false
    };

      let workouts = [];
      let exercises = [];
      let activeWorkout = null;
      let activeDefaults = { ...defaultSettings };
      let activeDefaultMusicSlug = null;
      let isAppReady = false;

      function sanitizeNumber(value, fallback, min) {
        const num = Number(value);
        if (Number.isFinite(num)) {
          return Math.max(min, Math.round(num));
        }
        return fallback;
      }

      function sanitizeSettings(input = {}) {
        return {
          prepareDuration: sanitizeNumber(input.prepareDuration, defaultSettings.prepareDuration, 0),
          totalRounds: sanitizeNumber(input.totalRounds, defaultSettings.totalRounds, 1),
          totalCycles: sanitizeNumber(input.totalCycles, defaultSettings.totalCycles, 1),
          workDuration: sanitizeNumber(input.workDuration, defaultSettings.workDuration, 5),
          restBetweenRounds: sanitizeNumber(input.restBetweenRounds, defaultSettings.restBetweenRounds, 0),
          restBetweenCycles: sanitizeNumber(input.restBetweenCycles, defaultSettings.restBetweenCycles, 0)
        };
      }

    function cloneSettings(settings) {
      return sanitizeSettings(settings);
    }

    function normalizeAudioLibrary(rawLibrary) {
      const library = {
        defaultMusic: null,
        music: [],
        prompts: {}
      };
      if (!rawLibrary || typeof rawLibrary !== 'object') {
        return library;
      }
      if (rawLibrary.defaultMusic) {
        library.defaultMusic = String(rawLibrary.defaultMusic).toLowerCase();
      }
      if (Array.isArray(rawLibrary.music)) {
        rawLibrary.music.forEach((item, index) => {
          if (!item) return;
          const slug = String(item.slug || item.url || `track-${index + 1}`).toLowerCase();
          const label =
            item.label ||
            slug.replace(/[-_]/g, ' ').replace(/\b\w/g, (char) => char.toUpperCase());
          library.music.push({
            slug,
            label,
            type: item.type || 'youtube',
            url: item.url || item.src || '',
            duration: Number.isFinite(Number(item.duration)) ? Number(item.duration) : null
          });
        });
      }
      if (rawLibrary.prompts && typeof rawLibrary.prompts === 'object') {
        Object.entries(rawLibrary.prompts).forEach(([key, value]) => {
          if (typeof value === 'string') {
            library.prompts[key] = value;
          }
        });
      }
      if (!library.defaultMusic && library.music.length > 0) {
        library.defaultMusic = library.music[0].slug;
      }
      return library;
    }

    function formatTime(totalSeconds) {
      const clamped = Math.max(0, Math.round(totalSeconds));
      const hours = Math.floor(clamped / 3600);
      const minutes = Math.floor((clamped % 3600) / 60);
        const seconds = clamped % 60;
        const segments = [];
        if (hours > 0) {
          segments.push(String(hours).padStart(2, '0'));
        }
        segments.push(String(minutes).padStart(2, '0'));
        segments.push(String(seconds).padStart(2, '0'));
        return segments.join(':');
      }

      function extractYouTubeId(raw) {
        if (!raw) return null;
        if (/^[\w-]{11}$/.test(raw)) {
          return raw;
        }
        try {
          const url = new URL(raw, window.location.href);
          const host = url.hostname.replace(/^www\./, '');
          if (host === 'youtu.be') {
            return url.pathname.slice(1).split('/')[0] || null;
          }
          if (host === 'youtube.com' || host === 'music.youtube.com') {
            if (url.searchParams.has('v')) {
              return url.searchParams.get('v');
            }
            const parts = url.pathname.split('/').filter(Boolean);
            const embedIndex = parts.indexOf('embed');
            if (embedIndex !== -1 && parts[embedIndex + 1]) {
              return parts[embedIndex + 1];
            }
            if (parts[0] === 'shorts' && parts[1]) {
              return parts[1];
            }
          }
        } catch (error) {
          return null;
        }
        return null;
      }

      function resolveVideoConfig(video) {
        if (!video) return null;
        if (typeof video === 'string') {
          const youtubeId = extractYouTubeId(video);
          if (youtubeId) {
            return {
              kind: 'youtube',
              src: `https://www.youtube.com/embed/${youtubeId}`,
              videoId: youtubeId
            };
          }
          return {
            kind: 'file',
            src: video
          };
        }
        if (typeof video === 'object') {
          if (video.type === 'youtube') {
            const explicitEmbed = video.embed ?? video.src;
            const youtubeId = video.id ?? extractYouTubeId(video.url ?? explicitEmbed);
            const src = explicitEmbed ?? (youtubeId ? `https://www.youtube.com/embed/${youtubeId}` : null);
            if (src) {
              return {
                kind: 'youtube',
                src,
                title: video.title ?? '',
                videoId: youtubeId ?? null
              };
            }
          }
          const src = video.src ?? video.url;
          if (src) {
            return {
              kind: 'file',
              src,
              title: video.title ?? ''
            };
          }
        }
        return null;
      }

      function withYouTubeLoop(src, videoId) {
        try {
          const url = new URL(src, window.location.href);
          url.searchParams.set('loop', '1');
          url.searchParams.set('autoplay', '1');
          url.searchParams.set('mute', '1');
          url.searchParams.set('playsinline', '1');
          const id = videoId || url.pathname.split('/').filter(Boolean).pop();
          if (id) {
            url.searchParams.set('playlist', id);
          }
          return url.toString();
        } catch (error) {
          const params = new URLSearchParams();
          params.set('loop', '1');
          params.set('autoplay', '1');
          params.set('mute', '1');
          params.set('playsinline', '1');
          if (videoId) {
            params.set('playlist', videoId);
          }
          const separator = src.includes('?') ? '&' : '?';
          return `${src}${separator}${params.toString()}`;
        }
      }

      function createVideoWrapper(videoConfig, index) {
        const wrapper = document.createElement('div');
        wrapper.className = 'video-wrapper';
        const resolved = resolveVideoConfig(videoConfig);
        if (resolved?.kind === 'youtube') {
          const iframe = document.createElement('iframe');
          iframe.src = withYouTubeLoop(resolved.src, resolved.videoId ?? null);
          iframe.title = resolved.title || `Exercise video ${index + 1}`;
          iframe.loading = 'lazy';
          iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
          iframe.referrerPolicy = 'strict-origin-when-cross-origin';
          iframe.allowFullscreen = true;
          wrapper.appendChild(iframe);
          return wrapper;
        }
        if (resolved?.kind === 'file') {
          const video = document.createElement('video');
          video.src = resolved.src;
          video.controls = true;
          video.preload = 'metadata';
          video.autoplay = true;
          video.muted = true;
          video.defaultMuted = true;
          video.loop = true;
          video.playsInline = true;
          video.setAttribute('muted', '');
          video.setAttribute('autoplay', '');
          video.setAttribute('playsinline', '');
          video.title = resolved.title || `Exercise video ${index + 1}`;
          wrapper.appendChild(video);
          return wrapper;
        }
        const placeholder = document.createElement('div');
        placeholder.className = 'video-placeholder';
        placeholder.textContent = `Video ${index + 1}`;
        wrapper.appendChild(placeholder);
        return wrapper;
      }

      function renderExerciseCards() {
        exerciseGrid.innerHTML = '';
        if (!Array.isArray(exercises) || exercises.length === 0) {
          const empty = document.createElement('p');
          empty.textContent = 'No exercises configured for this workout yet.';
          exerciseGrid.appendChild(empty);
          return;
        }
        exercises.forEach((exercise, index) => {
          const card = document.createElement('article');
          card.className = 'exercise-card';
          card.dataset.index = index;
          const videoWrapper = createVideoWrapper(exercise.video, index);
          const textWrapper = document.createElement('div');
          const heading = document.createElement('h3');
          heading.textContent = exercise.name;
          const description = document.createElement('p');
          description.textContent = exercise.description;
          textWrapper.appendChild(heading);
          textWrapper.appendChild(description);
          card.appendChild(videoWrapper);
          card.appendChild(textWrapper);
          exerciseGrid.appendChild(card);
        });
      }

      function highlightExercise(index) {
        elements.cards().forEach((card, cardIndex) => {
          card.classList.toggle('active', cardIndex === index);
        });
      }

      function updateProgressRing(element, progress) {
        if (!element) return;
        const clamped = Math.max(0, Math.min(progress, 1));
        element.style.setProperty('--angle', `${clamped * 360}deg`);
      }

      function setRoundArcs({ restFraction, workFraction, elapsedFraction }) {
        if (!arcs.rest || !arcs.work || !arcs.active) return;
        const clamp = (value) => Math.max(0, Math.min(1, value || 0));
        let rest = clamp(restFraction);
        let work = clamp(workFraction);
        let elapsed = clamp(elapsedFraction);
        const total = rest + work + elapsed;
        if (total > 1) {
          const scale = 1 / total;
          rest *= scale;
          work *= scale;
          elapsed *= scale;
        }
        const restLength = ARC_CIRCUMFERENCE * rest;
        const workLength = ARC_CIRCUMFERENCE * work;
        const elapsedLength = ARC_CIRCUMFERENCE * elapsed;

        arcs.rest.style.strokeDasharray = `${restLength} ${ARC_CIRCUMFERENCE}`;
        arcs.rest.style.strokeDashoffset = 0;
        arcs.rest.style.opacity = restLength > 0 ? 1 : 0;

        arcs.work.style.strokeDasharray = `${workLength} ${ARC_CIRCUMFERENCE}`;
        arcs.work.style.strokeDashoffset = -restLength;
        arcs.work.style.opacity = workLength > 0 ? 1 : 0;

        arcs.active.style.strokeDasharray = `${elapsedLength} ${ARC_CIRCUMFERENCE}`;
        arcs.active.style.strokeDashoffset = -(restLength + workLength);
        arcs.active.style.opacity = elapsedLength > 0 ? 1 : 0.25;
      }

      function clearRoundArcs() {
        if (!arcs.work || !arcs.rest || !arcs.active) return;
        arcs.work.style.strokeDasharray = `0 ${ARC_CIRCUMFERENCE}`;
        arcs.rest.style.strokeDasharray = `0 ${ARC_CIRCUMFERENCE}`;
        arcs.active.style.strokeDasharray = `${ARC_CIRCUMFERENCE} ${ARC_CIRCUMFERENCE}`;
        arcs.work.style.opacity = 0;
        arcs.rest.style.opacity = 0;
        arcs.active.style.opacity = 0.25;
        arcs.work.style.strokeDashoffset = 0;
        arcs.rest.style.strokeDashoffset = 0;
        arcs.active.style.strokeDashoffset = 0;
      }

      function updateRoundDisplay(segment) {
        if (!segment) {
          clearRoundArcs();
          return;
        }
        if (segment.type === 'restCycle') {
          const total = segment.duration || 1;
          const restRemaining = Math.max(0, Math.min(segment.duration, state.segmentRemaining));
          const restFraction = total > 0 ? restRemaining / total : 0;
          const elapsedFraction = 1 - restFraction;
          setRoundArcs({
            restFraction,
            workFraction: 0,
            elapsedFraction
          });
          return;
        }

        const workDuration = Math.max(0, config.workDuration);
        let restPlanned = 0;
        if (segment.type === 'work') {
          restPlanned = segment.round < config.totalRounds ? Math.max(0, config.restBetweenRounds) : 0;
        } else if (segment.type === 'restRound') {
          restPlanned = Math.max(0, segment.duration);
        } else {
          restPlanned = Math.max(0, config.restBetweenRounds);
        }

        const totalRound = workDuration + restPlanned;
        if (totalRound <= 0) {
          clearRoundArcs();
          return;
        }

        let workRemaining = 0;
        if (segment.type === 'work') {
          workRemaining = Math.max(0, Math.min(workDuration, state.segmentRemaining));
        } else if (segment.type === 'prepare') {
          workRemaining = workDuration;
        }

        let restRemaining = 0;
        if (segment.type === 'restRound') {
          restRemaining = Math.max(0, Math.min(restPlanned, state.segmentRemaining));
        } else if (segment.type === 'work' || segment.type === 'prepare') {
          restRemaining = restPlanned;
        }

        restRemaining = Math.max(0, Math.min(restPlanned, restRemaining));

        const restFraction = restRemaining / totalRound;
        const workFraction = workRemaining / totalRound;
        const elapsedFraction = Math.max(0, 1 - restFraction - workFraction);

        setRoundArcs({ restFraction, workFraction, elapsedFraction });
      }

    function resetPromptState() {
      promptState.segmentKey = null;
      promptState.countdownPlayed = false;
      promptState.tenSecondPlayed = false;
      promptState.threeSecondPlayed = false;
      promptState.completed = false;
    }

    function getMusicTrack(slug) {
      if (!audioLibrary.music.length) return null;
      if (!slug) return audioLibrary.music[0];
      return audioLibrary.music.find((track) => track.slug === slug) ?? audioLibrary.music[0];
    }

    function setPlayerVolume(volumePercent) {
      if (!audioState.player || typeof audioState.player.setVolume !== 'function') return;
      const clamped = Math.max(0, Math.min(100, Math.round(volumePercent)));
      try {
        audioState.player.setVolume(clamped);
      } catch (error) {
        console.warn('Unable to adjust music volume.', error);
      }
    }

    function unduckMusic() {
      if (audioState.duckTimeout) {
        clearTimeout(audioState.duckTimeout);
        audioState.duckTimeout = null;
      }
      if (audioState.playerReady) {
        setPlayerVolume(audioState.baseVolume);
      }
    }

    function duckMusic(duration = 1500) {
      if (!audioState.isPlaying || !audioState.playerReady) return;
      unduckMusic();
      setPlayerVolume(audioState.duckVolume);
      audioState.duckTimeout = setTimeout(() => {
        unduckMusic();
      }, duration);
    }

    function playPrompt(key, options = {}) {
      const src = promptSources.get(key);
      if (!src) return;
      const { duck = true } = options;
      try {
        const audio = new Audio(src);
        audio.preload = 'auto';
        audio.volume = 1;
        if (duck && audioState.isPlaying) {
          const applyDuck = () => {
            const duration = Number.isFinite(audio.duration) && audio.duration > 0 ? (audio.duration * 1000) + 250 : 1800;
            duckMusic(duration);
          };
          if (Number.isFinite(audio.duration) && audio.duration > 0) {
            applyDuck();
          } else {
            audio.addEventListener('loadedmetadata', applyDuck, { once: true });
            duckMusic();
          }
          audio.addEventListener('ended', unduckMusic, { once: true });
        }
        audio.play().catch((error) => {
          console.warn(`Prompt ${key} failed to play.`, error);
        });
      } catch (error) {
        console.warn(`Prompt ${key} failed to initialise.`, error);
      }
    }

    function ensureYouTubeApi() {
      if (youTubeState.ready) return Promise.resolve();
      return new Promise((resolve) => {
        if (youTubeState.ready) {
          resolve();
          return;
        }
        youTubeState.resolveQueue.push(resolve);
        if (!youTubeState.apiRequested) {
          youTubeState.apiRequested = true;
          const previousHandler = window.onYouTubeIframeAPIReady;
          window.onYouTubeIframeAPIReady = function onYouTubeIframeAPIReady() {
            youTubeState.ready = true;
            youTubeState.resolveQueue.splice(0).forEach((queuedResolve) => queuedResolve());
            if (typeof previousHandler === 'function') {
              previousHandler();
            }
          };
          const script = document.createElement('script');
          script.id = 'youtube-iframe-api';
          script.src = 'https://www.youtube.com/iframe_api';
          document.head.appendChild(script);
        }
      });
    }

    function bindPlayerEvents(player) {
      if (!player) return;
      player.addEventListener('onStateChange', (event) => {
        if (event.data === window.YT?.PlayerState?.PLAYING) {
          audioState.isPlaying = true;
          setPlayerVolume(audioState.baseVolume);
        } else if (event.data === window.YT?.PlayerState?.PAUSED) {
          audioState.isPlaying = false;
        } else if (event.data === window.YT?.PlayerState?.ENDED) {
          if (audioState.shouldPlay) {
            event.target.seekTo(0, true);
            event.target.playVideo();
          } else {
            audioState.isPlaying = false;
          }
        }
      });
    }

    async function loadYouTubeTrack(track, { autoPlay = false } = {}) {
      const videoId = extractYouTubeId(track?.url ?? track?.src);
      if (!videoId) {
        console.warn('No valid video id for track', track);
        return;
      }
      audioState.currentTrack = track;
      audioState.pendingTrackId = videoId;
      audioState.pendingAutoPlay = !!autoPlay;

      await ensureYouTubeApi();

      if (!audioState.player) {
        audioState.player = new window.YT.Player('musicPlayerHost', {
          height: '0',
          width: '0',
          playerVars: {
            autoplay: 0,
            controls: 0,
            rel: 0,
            playsinline: 1,
            modestbranding: 1
          },
          events: {
            onReady: () => {
              audioState.playerReady = true;
              setPlayerVolume(audioState.baseVolume);
              const pendingId = audioState.pendingTrackId;
              const shouldAuto = audioState.pendingAutoPlay || audioState.shouldPlay;
              if (pendingId && typeof audioState.player.cueVideoById === 'function') {
                if (shouldAuto && typeof audioState.player.loadVideoById === 'function') {
                  audioState.player.loadVideoById(pendingId, 0);
                } else {
                  audioState.player.cueVideoById(pendingId, 0);
                }
              }
              if (shouldAuto) {
                playMusicInternal();
              } else {
                audioState.pendingPlay = false;
              }
              audioState.pendingAutoPlay = false;
              audioState.pendingTrackId = null;
            }
          }
        });
        bindPlayerEvents(audioState.player);
        return;
      }

      audioState.playerReady = true;
      if (autoPlay || audioState.shouldPlay) {
        if (typeof audioState.player.loadVideoById === 'function') {
          audioState.player.loadVideoById(videoId, 0);
        }
        playMusicInternal();
      } else if (typeof audioState.player.cueVideoById === 'function') {
        audioState.player.cueVideoById(videoId, 0);
      } else if (typeof audioState.player.loadVideoById === 'function') {
        audioState.player.loadVideoById(videoId, 0);
        if (typeof audioState.player.pauseVideo === 'function') {
          audioState.player.pauseVideo();
        }
      }
      audioState.pendingTrackId = null;
      audioState.pendingAutoPlay = false;
    }

    function playMusicInternal() {
      if (!audioState.player || !audioState.playerReady) {
        audioState.pendingPlay = true;
        return;
      }
      audioState.pendingPlay = false;
      try {
        if (typeof audioState.player.playVideo === 'function') {
          audioState.player.playVideo();
          setPlayerVolume(audioState.baseVolume);
          audioState.isPlaying = true;
        }
      } catch (error) {
        console.warn('Unable to play music track.', error);
      }
    }

    function playMusic() {
      audioState.shouldPlay = true;
      if (!audioState.selectedMusicSlug && audioLibrary.music.length > 0) {
        audioState.selectedMusicSlug = audioLibrary.music[0].slug;
      }
      if (!audioState.currentTrack || audioState.currentTrack.slug !== audioState.selectedMusicSlug) {
        const result = setMusicTrackBySlug(audioState.selectedMusicSlug, { autoPlay: true });
        if (result && typeof result.then === 'function') {
          result.then(() => {
            if (audioState.shouldPlay) {
              playMusicInternal();
            }
          });
        }
        return;
      }
      playMusicInternal();
    }

    function pauseMusic(silent = false) {
      audioState.shouldPlay = false;
      audioState.pendingPlay = false;
      if (audioState.player && audioState.playerReady) {
        try {
          if (typeof audioState.player.pauseVideo === 'function') {
            audioState.player.pauseVideo();
          }
        } catch (error) {
          console.warn('Unable to pause music.', error);
        }
      }
      audioState.isPlaying = false;
      unduckMusic();
    }

    function stopMusic() {
      pauseMusic(true);
      audioState.pendingAutoPlay = false;
      audioState.pendingTrackId = null;
      if (audioState.player && audioState.playerReady) {
        try {
          if (typeof audioState.player.stopVideo === 'function') {
            audioState.player.stopVideo();
          }
          if (typeof audioState.player.seekTo === 'function') {
            audioState.player.seekTo(0, true);
          }
        } catch (error) {
          console.warn('Unable to stop music.', error);
        }
      }
    }

    function loadPromptSources(prompts) {
      promptSources.clear();
      if (!prompts) return;
      Object.entries(prompts).forEach(([key, value]) => {
        if (typeof value === 'string') {
          promptSources.set(key, value);
        }
      });
    }

    function populateMusicSelect() {
      if (!musicSelect) return;
      musicSelect.innerHTML = '';
      if (!audioLibrary.music.length) {
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'No tracks available';
        musicSelect.appendChild(option);
        musicSelect.disabled = true;
        return;
      }
      audioLibrary.music.forEach((track) => {
        const option = document.createElement('option');
        option.value = track.slug;
        option.textContent = track.label || track.slug;
        musicSelect.appendChild(option);
      });
      musicSelect.disabled = false;
      const preferred =
        audioState.selectedMusicSlug ??
        audioLibrary.defaultMusic ??
        (audioLibrary.music[0]?.slug ?? '');
      setMusicSelectValue(preferred);
    }

    function setMusicSelectValue(slug) {
      if (!musicSelect) return;
      const value = slug ?? '';
      if (musicSelect.value !== value) {
        musicSelect.value = value;
      }
    }

    function setMusicTrackBySlug(slug, options = {}) {
      const track = getMusicTrack(slug);
      audioState.selectedMusicSlug = track?.slug ?? null;
      setMusicSelectValue(audioState.selectedMusicSlug);
      if (!track) {
        audioState.currentTrack = null;
        stopMusic();
        return Promise.resolve();
      }
      if (track.type === 'youtube') {
        return loadYouTubeTrack(track, { autoPlay: !!options.autoPlay });
      }
      return Promise.resolve();
    }

    function handleSegmentPrompts(segment) {
      if (!segment) {
        if (!promptState.completed) {
          playPrompt('finished', { duck: false });
          stopMusic();
          promptState.completed = true;
        }
        return;
      }
      promptState.completed = false;
      const key = `${state.currentSegmentIndex}:${segment.type}`;
      const isNewSegment = key !== promptState.segmentKey;
      if (isNewSegment) {
        promptState.segmentKey = key;
        promptState.countdownPlayed = false;
        promptState.tenSecondPlayed = false;
        promptState.threeSecondPlayed = false;
        if (state.isRunning && !state.isPaused) {
          if (segment.type === 'work') {
            playPrompt('start');
          } else if (segment.type === 'restRound' || segment.type === 'restCycle') {
            playPrompt('rest');
          }
        }
      }
      if (!state.isRunning || state.isPaused) {
        return;
      }
      if (segment.type === 'prepare' && !promptState.countdownPlayed && state.segmentRemaining <= 3.05) {
        playPrompt('countdown');
        promptState.countdownPlayed = true;
      }
      if (segment.type === 'work' && !promptState.tenSecondPlayed && state.segmentRemaining <= 10.05) {
        playPrompt('tenSecondsLeft');
        promptState.tenSecondPlayed = true;
      }
      if ((segment.type === 'work' || segment.type.startsWith('rest')) && !promptState.threeSecondPlayed && state.segmentRemaining <= 3.05) {
        playPrompt('beeps');
        promptState.threeSecondPlayed = true;
      }
    }

      function buildSchedule() {
        const segments = [];
        let globalRound = 0;
        const exerciseCount = exercises.length;

        if (config.prepareDuration > 0) {
          segments.push({
            type: 'prepare',
            duration: config.prepareDuration,
            round: 0,
            cycle: 0,
            globalRound: 0,
            exerciseIndex: exerciseCount > 0 ? 0 : -1
          });
        }

        for (let cycle = 1; cycle <= config.totalCycles; cycle += 1) {
          for (let round = 1; round <= config.totalRounds; round += 1) {
            globalRound += 1;
            const exerciseIndex = exerciseCount > 0 ? (globalRound - 1) % exerciseCount : -1;
            segments.push({
              type: 'work',
              duration: config.workDuration,
              round,
              cycle,
              globalRound,
              exerciseIndex
            });

            const hasNextRoundInCycle = round < config.totalRounds;
            if (hasNextRoundInCycle && config.restBetweenRounds > 0) {
              const nextExerciseIndex = exerciseCount > 0 ? globalRound % exerciseCount : -1;
              segments.push({
                type: 'restRound',
                duration: config.restBetweenRounds,
                round,
                cycle,
                globalRound,
                exerciseIndex: nextExerciseIndex
              });
            }
          }

          const hasNextCycle = cycle < config.totalCycles && config.restBetweenCycles > 0;
          if (hasNextCycle) {
            const nextExerciseIndex = exerciseCount > 0 ? globalRound % exerciseCount : -1;
            segments.push({
              type: 'restCycle',
              duration: config.restBetweenCycles,
              round: config.totalRounds,
              cycle,
              globalRound,
              exerciseIndex: nextExerciseIndex
            });
          }
        }

        state.schedule = segments;
        state.totalDuration = segments.reduce((sum, seg) => sum + seg.duration, 0);
      }

      function setSegment(index, remaining) {
        if (state.schedule.length === 0) return;
        state.currentSegmentIndex = Math.max(0, Math.min(index, state.schedule.length - 1));
        const segment = state.schedule[state.currentSegmentIndex];
        state.segmentRemaining = remaining ?? segment.duration;
        state.totalRemaining = state.segmentRemaining;
        for (let i = state.currentSegmentIndex + 1; i < state.schedule.length; i += 1) {
          state.totalRemaining += state.schedule[i].duration;
        }
        updateUI();
      }

    function resetState() {
      buildSchedule();
      resetPromptState();
      state.isRunning = false;
      state.isPaused = false;
      state.lastTimestamp = null;
      if (state.animationFrame) {
        cancelAnimationFrame(state.animationFrame);
        state.animationFrame = null;
      }
      if (state.schedule.length === 0) {
        state.totalDuration = 0;
        state.totalRemaining = 0;
        state.segmentRemaining = 0;
        state.currentSegmentIndex = 0;
        updateUI();
        return;
      }
      setSegment(0, state.schedule[0].duration);
    }

    function getExerciseName(index) {
      if (index == null || index < 0) return 'Circuit';
      return exercises[index]?.name ?? 'Circuit';
    }

    function updateUI() {
      const segment = state.schedule[state.currentSegmentIndex];
      const nextSegment = state.schedule[state.currentSegmentIndex + 1];
      const totalRounds = Math.max(1, config.totalRounds);
      const totalCycles = Math.max(1, config.totalCycles);

      const resolvedRound = segment && segment.round > 0 ? Math.min(segment.round, totalRounds) : 1;
      const resolvedCycle = segment && segment.cycle > 0 ? Math.min(segment.cycle, totalCycles) : 1;

      updateProgressRing(elements.roundProgress, totalRounds ? resolvedRound / totalRounds : 0);
      updateProgressRing(elements.cycleProgress, totalCycles ? resolvedCycle / totalCycles : 0);

      elements.roundTracker.textContent = `${resolvedRound} / ${totalRounds}`;
      elements.cycleTracker.textContent = `${resolvedCycle} / ${totalCycles}`;

      const totalRemaining = Math.max(0, state.totalRemaining);
      elements.segmentCountdown.textContent = formatTime(totalRemaining);
      elements.summaryLabel.textContent = `Round ${resolvedRound} · Cycle ${resolvedCycle} · ${formatTime(totalRemaining)} left`;

      if (!segment) {
        elements.timerRing.dataset.phase = 'complete';
        elements.timerLabel.textContent = 'Complete';
        elements.phaseIndicator.textContent = 'Workout complete';
        elements.phaseTime.textContent = '00:00';
        clearRoundArcs();
        highlightExercise(-1);
        elements.currentAction.textContent = 'Finished';
        elements.currentExercise.textContent = 'Workout complete. Great effort!';
        elements.nextAction.textContent = '—';
        elements.nextExercise.textContent = 'Session complete';
        return;
      }

      const phaseMeta = {
        prepare: { phase: 'prepare', label: 'Prepare' },
        work: { phase: 'work', label: 'Work' },
        restRound: { phase: 'rest', label: 'Rest' },
        restCycle: { phase: 'cycleRest', label: 'Cycle Rest' }
      }[segment.type] ?? { phase: 'prepare', label: 'Prepare' };

      const paused = state.isPaused && state.isRunning;
      elements.timerRing.dataset.phase = paused ? 'paused' : phaseMeta.phase;
      elements.timerLabel.textContent = paused ? 'Paused' : phaseMeta.label;
      elements.phaseTime.textContent = formatTime(state.segmentRemaining);

      updateRoundDisplay(segment);

      let currentExerciseText = '';
      let highlightIndex = segment.exerciseIndex ?? -1;

      if (segment.type === 'prepare') {
        const firstWork = state.schedule.find((entry) => entry.type === 'work');
        const firstName = firstWork ? getExerciseName(firstWork.exerciseIndex) : 'first exercise';
        currentExerciseText = firstWork ? `First up: ${firstName}` : 'Dial in your form.';
        highlightIndex = firstWork ? firstWork.exerciseIndex : -1;
      } else if (segment.type === 'work') {
        currentExerciseText = `Go hard: ${getExerciseName(highlightIndex)}`;
      } else if (segment.type === 'restRound') {
        const nextWork = state.schedule.slice(state.currentSegmentIndex + 1).find((entry) => entry.type === 'work');
        const nextName = nextWork ? getExerciseName(nextWork.exerciseIndex) : getExerciseName(segment.exerciseIndex);
        currentExerciseText = nextWork ? `Recover before ${nextName}` : 'Take a quick breather.';
        highlightIndex = nextWork ? nextWork.exerciseIndex : segment.exerciseIndex ?? -1;
      } else if (segment.type === 'restCycle') {
        const targetCycle = Math.min(segment.cycle + 1, config.totalCycles);
        currentExerciseText = segment.cycle < config.totalCycles ? `Reset for cycle ${targetCycle}` : 'Cool down and celebrate.';
        highlightIndex = -1;
      } else {
        currentExerciseText = 'Stay focused and breathe.';
      }

      if (paused) {
        elements.phaseIndicator.textContent = 'Paused';
        elements.currentAction.textContent = 'Paused';
        elements.currentExercise.textContent = currentExerciseText;
      } else {
        elements.phaseIndicator.textContent = phaseMeta.label;
        elements.currentAction.textContent = phaseMeta.label;
        elements.currentExercise.textContent = currentExerciseText;
      }

      highlightExercise(highlightIndex);

      if (nextSegment) {
        const nextLabel = {
          prepare: 'Prepare',
          work: 'Work',
          restRound: 'Rest',
          restCycle: 'Cycle Rest'
        }[nextSegment.type] ?? 'Prepare';
        elements.nextAction.textContent = nextLabel;
        if (nextSegment.type === 'work') {
          elements.nextExercise.textContent = getExerciseName(nextSegment.exerciseIndex);
        } else if (nextSegment.type === 'restRound') {
          elements.nextExercise.textContent = 'Recovery window';
        } else if (nextSegment.type === 'restCycle') {
          const targetCycle = Math.min(nextSegment.cycle + 1, config.totalCycles);
          elements.nextExercise.textContent = nextSegment.cycle < config.totalCycles ? `Reset for cycle ${targetCycle}` : 'Cool down';
        } else {
          elements.nextExercise.textContent = 'Pre-start countdown';
        }
      } else {
        elements.nextAction.textContent = 'Finish';
        elements.nextExercise.textContent = 'Final push to complete.';
      }

      handleSegmentPrompts(segment);

      const initialDuration = state.schedule[0]?.duration ?? 0;
      const atBeginning =
        state.currentSegmentIndex === 0 &&
        Math.abs(state.segmentRemaining - initialDuration) < 0.5 &&
        !state.isRunning;
      const atEnd =
        state.currentSegmentIndex >= state.schedule.length - 1 &&
        !state.isRunning &&
        state.totalRemaining < 0.5;

      controls.start.disabled = state.isRunning && !state.isPaused;
      controls.pause.disabled = !state.isRunning;
      controls.pause.textContent = state.isPaused ? 'Resume' : 'Pause';
      controls.stop.disabled = atBeginning && !state.isRunning;
      controls.reset.disabled = atBeginning && !state.isRunning;
      controls.prev.disabled =
        state.schedule.length === 0 ||
        findNextWork(state.currentSegmentIndex, -1) === state.currentSegmentIndex;
      controls.next.disabled =
        state.schedule.length === 0 ||
        findNextWork(state.currentSegmentIndex, 1) === state.currentSegmentIndex ||
        atEnd;
    }

      function advance(delta) {
        let remainingDelta = delta;
        while (remainingDelta > 0 && state.schedule[state.currentSegmentIndex]) {
          if (state.segmentRemaining > remainingDelta) {
            state.segmentRemaining -= remainingDelta;
            state.totalRemaining = Math.max(0, state.totalRemaining - remainingDelta);
            remainingDelta = 0;
          } else {
            remainingDelta -= state.segmentRemaining;
            state.totalRemaining = Math.max(0, state.totalRemaining - state.segmentRemaining);
            const nextIndex = state.currentSegmentIndex + 1;
            if (nextIndex >= state.schedule.length) {
              state.segmentRemaining = 0;
              state.currentSegmentIndex = nextIndex;
              state.isRunning = false;
              if (state.animationFrame) {
                cancelAnimationFrame(state.animationFrame);
                state.animationFrame = null;
              }
              break;
            }
            state.currentSegmentIndex = nextIndex;
            state.segmentRemaining = state.schedule[state.currentSegmentIndex].duration;
          }
        }
        updateUI();
      }

      function tick(timestamp) {
        if (!state.isRunning || state.isPaused) return;
        if (state.lastTimestamp == null) {
          state.lastTimestamp = timestamp;
        }
        const delta = (timestamp - state.lastTimestamp) / 1000;
        state.lastTimestamp = timestamp;
        advance(delta);
        if (state.isRunning && !state.isPaused) {
          state.animationFrame = requestAnimationFrame(tick);
        }
      }

      function startTimer() {
        if (state.schedule.length === 0 || state.currentSegmentIndex >= state.schedule.length) {
          resetState();
        }
        if (!state.isRunning) {
          state.isRunning = true;
          state.isPaused = false;
          state.lastTimestamp = null;
          playMusic();
          state.animationFrame = requestAnimationFrame(tick);
        } else if (state.isPaused) {
          state.isPaused = false;
          state.lastTimestamp = null;
          playMusic();
          state.animationFrame = requestAnimationFrame(tick);
        }
        updateUI();
      }

    function pauseTimer() {
      if (!state.isRunning) return;
      state.isPaused = !state.isPaused;
      if (state.isPaused) {
        pauseMusic();
        playPrompt('pause', { duck: false });
      } else {
        playMusic();
        playPrompt('start');
        state.lastTimestamp = null;
        state.animationFrame = requestAnimationFrame(tick);
      }
      updateUI();
    }

    function stopTimer() {
      state.isRunning = false;
      state.isPaused = false;
      if (state.animationFrame) {
        cancelAnimationFrame(state.animationFrame);
        state.animationFrame = null;
      }
      resetState();
      stopMusic();
    }

    function resetTimer() {
      if (state.animationFrame) {
        cancelAnimationFrame(state.animationFrame);
        state.animationFrame = null;
      }
      state.isRunning = false;
      state.isPaused = false;
      resetPromptState();
      setSegment(0, state.schedule[0]?.duration ?? 0);
      pauseMusic(true);
      updateUI();
    }

    function findNextWork(fromIndex, direction) {
      if (state.schedule.length === 0) return fromIndex;
      if (direction > 0) {
        for (let i = fromIndex + 1; i < state.schedule.length; i += 1) {
          if (state.schedule[i].type === 'work') return i;
        }
        return fromIndex;
      }
      for (let i = fromIndex - 1; i >= 0; i -= 1) {
        if (state.schedule[i].type === 'work') return i;
      }
      return fromIndex;
    }

    function skip(direction) {
      if (state.schedule.length === 0) return;
      const nextWorkIndex = findNextWork(state.currentSegmentIndex, direction);
      if (nextWorkIndex === state.currentSegmentIndex) {
        return;
      }
      resetPromptState();
      setSegment(nextWorkIndex, state.schedule[nextWorkIndex].duration);
      state.lastTimestamp = null;
    }

    controls.start.addEventListener('click', startTimer);
    controls.pause.addEventListener('click', pauseTimer);
    controls.stop.addEventListener('click', stopTimer);
    controls.reset.addEventListener('click', resetTimer);
    controls.next.addEventListener('click', () => skip(1));
    controls.prev.addEventListener('click', () => skip(-1));

    openConfigBtn.addEventListener('click', () => {
      configPanel.dataset.open = 'true';
    });

    closeConfigBtn.addEventListener('click', () => {
      configPanel.dataset.open = 'false';
    });

    applyDefaultsBtn.addEventListener('click', () => {
      if (!activeDefaults) return;
      setFormValuesFromSettings(activeDefaults);
      updateConfigFromForm();
      const defaultMusicSlug =
        activeDefaultMusicSlug ||
        audioLibrary.defaultMusic ||
        (audioLibrary.music[0]?.slug ?? null);
      if (defaultMusicSlug) {
        const autoPlay = state.isRunning && !state.isPaused;
        setMusicTrackBySlug(defaultMusicSlug, { autoPlay });
      }
    });

      function setFormValuesFromSettings(settings) {
        form.prepareDuration.value = settings.prepareDuration;
        form.rounds.value = settings.totalRounds;
        form.cycles.value = settings.totalCycles;
        form.workDuration.value = settings.workDuration;
        form.restRounds.value = settings.restBetweenRounds;
        form.restCycles.value = settings.restBetweenCycles;
      }

      function syncFormFromConfig() {
        setFormValuesFromSettings(config);
      }

      function applySettingsToConfig(settings) {
        const clean = sanitizeSettings(settings);
        Object.assign(config, clean);
        return clean;
      }

    function updateConfigFromForm() {
      const wasRunning = state.isRunning;
      const nextSettings = {
        prepareDuration: form.prepareDuration.value,
        totalRounds: form.rounds.value,
        totalCycles: form.cycles.value,
        workDuration: form.workDuration.value,
        restBetweenRounds: form.restRounds.value,
        restBetweenCycles: form.restCycles.value
      };
      applySettingsToConfig(nextSettings);
      if (isAppReady) {
        resetState();
        if (wasRunning) {
          stopMusic();
        }
        setWorkoutInUrl(activeWorkout?.slug);
      }
    }

      form.addEventListener('input', (event) => {
        if (event.target === musicSelect) return;
        updateConfigFromForm();
      });

      function normalizeWorkouts(rawList) {
        if (!Array.isArray(rawList)) return [];
        return rawList
          .map((item) => {
            if (!item || !item.slug) return null;
            const slug = String(item.slug).toLowerCase();
            const settings = sanitizeSettings(item.settings || {});
            const audio = item.audio && typeof item.audio === 'object'
              ? { music: item.audio.music ? String(item.audio.music).toLowerCase() : null }
              : { music: null };
            return {
              slug,
              title: item.title || slug.replace(/[-_]/g, ' ').replace(/\b\w/g, (char) => char.toUpperCase()),
              tagline: item.tagline || '',
              exercisesHeading: item.exercisesHeading || 'Exercise Circuit',
              summary: item.summary || '',
              settings,
              exercises: Array.isArray(item.exercises) ? item.exercises : [],
              audio
            };
          })
          .filter(Boolean);
      }

      async function loadWorkouts() {
        let loaded = false;
        try {
          const response = await fetch(workoutsEndpoint, { cache: 'no-store' });
          if (!response.ok) {
            throw new Error(`Failed to load workouts: ${response.status}`);
          }
          const payload = await response.json();
          const list = Array.isArray(payload) ? payload : Array.isArray(payload.workouts) ? payload.workouts : [];
          const normalized = normalizeWorkouts(list);
          if (normalized.length > 0) {
            workouts = normalized;
            audioLibrary = normalizeAudioLibrary(Array.isArray(payload) ? null : payload.audioLibrary);
            if (!audioLibrary.music.length) {
              audioLibrary = normalizeAudioLibrary(fallbackAudioLibrary);
            }
            loaded = true;
          }
        } catch (error) {
          console.warn('Falling back to bundled workouts.', error);
        }
        if (!loaded) {
          workouts = normalizeWorkouts(fallbackWorkouts);
          audioLibrary = normalizeAudioLibrary(fallbackAudioLibrary);
        }
        if (!audioLibrary.music.length) {
          audioLibrary = normalizeAudioLibrary(fallbackAudioLibrary);
        }
        if (!audioLibrary.defaultMusic && audioLibrary.music.length) {
          audioLibrary.defaultMusic = audioLibrary.music[0].slug;
        }
        loadPromptSources(audioLibrary.prompts);
      }

      function populateWorkoutSelect() {
        workoutSelect.innerHTML = '';
        workouts.forEach((workout) => {
          const option = document.createElement('option');
          option.value = workout.slug;
          option.textContent = workout.title;
          workoutSelect.appendChild(option);
        });
      }

      workoutSelect.addEventListener('change', (event) => {
        const slug = event.target.value;
        const workout = workouts.find((candidate) => candidate.slug === slug);
        if (workout) {
          selectWorkout(workout);
        }
      });

      if (musicSelect) {
        musicSelect.addEventListener('change', (event) => {
          const slug = event.target.value || null;
          const autoPlay = state.isRunning && !state.isPaused;
          setMusicTrackBySlug(slug, { autoPlay });
        });
      }

      function setWorkoutInUrl(slug) {
        if (!slug) return;
        const url = new URL(window.location.href);
        url.searchParams.set('workout', slug);
        const query = url.searchParams.toString();
        const newUrl = `${url.pathname}${query ? `?${query}` : ''}`;
        window.history.replaceState({}, '', newUrl);
      }

      function getWorkoutSlugFromUrl() {
        const url = new URL(window.location.href);
        const slugFromQuery = url.searchParams.get('workout');
        if (slugFromQuery) return slugFromQuery.toLowerCase();
        const hash = url.hash.replace(/^#/, '');
        return hash ? hash.toLowerCase() : null;
      }

      function updateBranding(workout) {
        if (elements.workoutTitle) {
          elements.workoutTitle.textContent = workout.title;
        }
        if (elements.workoutTagline) {
          elements.workoutTagline.textContent = workout.tagline || '';
        }
        if (elements.exercisesHeading) {
          elements.exercisesHeading.textContent = workout.exercisesHeading || 'Exercise Circuit';
        }
        document.title = workout.title;
      }

      function selectWorkout(workout) {
        if (!workout) return;
        if (state.animationFrame) {
          cancelAnimationFrame(state.animationFrame);
          state.animationFrame = null;
        }
        state.isRunning = false;
        state.isPaused = false;
        isAppReady = false;
        stopMusic();

        activeWorkout = workout;
        activeDefaults = cloneSettings(workout.settings);
        activeDefaultMusicSlug =
          (workout.audio && workout.audio.music ? String(workout.audio.music).toLowerCase() : null) ||
          audioLibrary.defaultMusic ||
          (audioLibrary.music[0]?.slug ?? null);
        exercises = Array.isArray(workout.exercises) ? workout.exercises.slice() : [];
        applySettingsToConfig(activeDefaults);
        syncFormFromConfig();
        renderExerciseCards();
        updateBranding(workout);
        workoutSelect.value = workout.slug;
        populateMusicSelect();
        if (activeDefaultMusicSlug) {
          setMusicTrackBySlug(activeDefaultMusicSlug);
        } else if (audioLibrary.music.length) {
          setMusicTrackBySlug(audioLibrary.music[0].slug);
        } else {
          setMusicSelectValue('');
        }
        resetState();
        highlightExercise(-1);
        setWorkoutInUrl(workout.slug);
        isAppReady = true;
      }

      function pickInitialWorkout() {
        const slug = getWorkoutSlugFromUrl();
        if (slug) {
          const match = workouts.find((workout) => workout.slug === slug);
          if (match) {
            return match;
          }
      }
      return workouts[0] ?? null;
    }

    function updateClock() {
      if (!elements.currentTime) return;
      const now = new Date();
      const formatted = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
      elements.currentTime.textContent = formatted;
    }

      async function initialize() {
        await loadWorkouts();
        populateWorkoutSelect();
        populateMusicSelect();
        const initialWorkout = pickInitialWorkout();
        if (initialWorkout) {
          selectWorkout(initialWorkout);
        } else {
          renderExerciseCards();
          resetState();
        }
      }

      updateClock();
      setInterval(updateClock, 30000);

      initialize();
    })();
  </script>

</body>
</html>
