<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RB100 30-Minute Workout</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #050b16;
      --panel: rgba(12, 20, 37, 0.85);
      --panel-strong: rgba(16, 28, 52, 0.92);
      --outline: rgba(255, 255, 255, 0.08);
      --text: #f4f6fb;
      --muted: rgba(244, 246, 251, 0.64);
      --accent: #4f7bff;
      --accent-soft: rgba(79, 123, 255, 0.22);
      --success: #4fd1c5;
      --phase-prepare: #f6c65c;
      --phase-work: #32d27c;
      --phase-rest: #ff6b6b;
      --phase-cycle: #7f93ff;
      --phase-paused: #f6c65c;
      --phase-track: rgba(255, 255, 255, 0.12);
      font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at 30% -10%, rgba(79, 123, 255, 0.2), transparent 55%),
        radial-gradient(circle at 80% 120%, rgba(79, 123, 255, 0.18), transparent 50%),
        var(--bg);
      color: var(--text);
      overflow: hidden;
    }

    .app-shell {
      position: relative;
      height: min(100vh, 3840px);
      aspect-ratio: 9 / 16;
      width: min(100vw, calc(min(100vh, 3840px) * 9 / 16));
      max-width: 1400px;
      border-radius: 32px;
      background: rgba(7, 12, 25, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 32px 68px rgba(0, 0, 0, 0.55);
      display: grid;
      grid-template-rows: auto 1fr auto;
      overflow: hidden;
      backdrop-filter: blur(24px);
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: clamp(20px, 2.5vh, 42px) clamp(28px, 3vw, 56px);
      background: linear-gradient(135deg, rgba(79, 123, 255, 0.25), rgba(79, 123, 255, 0));
      border-bottom: 1px solid var(--outline);
    }

    .branding h1 {
      margin: 0;
      font-size: clamp(1.45rem, 2.2vw, 2.4rem);
      letter-spacing: 0.22em;
      text-transform: uppercase;
    }

    .branding span {
      display: block;
      margin-top: 0.25rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      font-size: clamp(0.7rem, 1vw, 0.9rem);
      color: var(--muted);
    }

    .config-toggle {
      border: 1px solid rgba(255, 255, 255, 0.16);
      background: rgba(8, 15, 32, 0.7);
      color: inherit;
      font-size: clamp(0.85rem, 1vw, 1rem);
      letter-spacing: 0.15em;
      text-transform: uppercase;
      padding: 0.7em 1.4em;
      border-radius: 999px;
      display: flex;
      align-items: center;
      gap: 0.6em;
      cursor: pointer;
      transition: transform 160ms ease, background 160ms ease;
    }

    .config-toggle:hover,
    .config-toggle:focus-visible {
      transform: translateY(-2px);
      background: rgba(16, 26, 48, 0.95);
      outline: none;
    }

    main {
      display: grid;
      grid-template-columns: 1fr;
      grid-template-rows: 1fr auto;
      padding: clamp(24px, 3vh, 48px) clamp(28px, 3vw, 56px);
      gap: clamp(24px, 3vh, 44px);
    }

    .timer-section {
      display: grid;
      grid-template-rows: auto auto;
      gap: clamp(18px, 2.5vh, 28px);
    }

    .main-timer {
      display: grid;
      grid-template-columns: minmax(0, 1fr);
      justify-items: center;
      gap: clamp(16px, 2.5vh, 24px);
    }

    .timer-ring {
      position: relative;
      width: clamp(320px, 45vw, 520px);
      aspect-ratio: 1 / 1;
    }

    .timer-progress {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      display: grid;
      place-items: center;
      padding: clamp(18px, 2vw, 30px);
      transition: filter 180ms ease;
      pointer-events: none;
    }

    .timer-progress::after {
      content: "";
      position: absolute;
      inset: clamp(32px, 4vw, 48px);
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(5, 10, 20, 0.85);
    }

    .timer-svg {
      position: absolute;
      inset: clamp(18px, 2vw, 30px);
      width: auto;
      height: auto;
      overflow: visible;
    }

    .timer-svg circle {
      fill: none;
      stroke-linecap: round;
      stroke-width: clamp(12px, 1.6vw, 18px);
      transform: rotate(-90deg);
      transform-origin: 50% 50%;
    }

    .timer-track {
      stroke: rgba(255, 255, 255, 0.08);
    }

    .timer-arc {
      stroke-dasharray: 0 999;
      stroke-dashoffset: 0;
      opacity: 0;
      transition: opacity 200ms ease, stroke 160ms ease, stroke-dashoffset 120ms linear;
    }

    .timer-arc--work {
      stroke: var(--phase-work);
    }

    .timer-arc--rest {
      stroke: var(--phase-rest);
    }

    .timer-arc--active {
      stroke: var(--accent);
      opacity: 1;
    }

    .timer-ring[data-phase="prepare"] .timer-arc--active {
      stroke: var(--phase-prepare);
    }

    .timer-ring[data-phase="paused"] .timer-arc--active {
      stroke: var(--phase-paused);
    }

    .timer-ring[data-phase="cycleRest"] .timer-arc--active {
      stroke: var(--phase-cycle);
    }

    .timer-ring[data-phase="rest"] .timer-arc--active {
      stroke: var(--phase-rest);
    }

    .timer-ring[data-phase="work"] .timer-arc--active {
      stroke: var(--phase-work);
    }

    .timer-ring[data-round="true"] .timer-arc--work,
    .timer-ring[data-round="true"] .timer-arc--rest {
      opacity: 1;
    }

    .timer-inner {
      position: relative;
      z-index: 1;
      text-align: center;
      display: grid;
      gap: 0.35rem;
    }

    .timer-label {
      font-size: clamp(0.85rem, 1.1vw, 1.1rem);
      letter-spacing: 0.3em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .timer-value {
      font-size: clamp(3rem, 6vw, 4.4rem);
      font-weight: 700;
      letter-spacing: 0.18em;
    }

    .phase-indicator {
      font-size: clamp(1.05rem, 1.6vw, 1.5rem);
      letter-spacing: 0.28em;
      text-transform: uppercase;
      color: var(--accent);
    }

    .mini-progress-grid {
      display: grid;
      grid-template-columns: repeat(2, clamp(130px, 18vw, 180px));
      gap: clamp(12px, 2vw, 32px);
      justify-content: center;
    }

    .mini-progress {
      position: relative;
      border-radius: 50%;
      aspect-ratio: 1 / 1;
      --angle: 0deg;
      background:
        radial-gradient(circle at center, rgba(12, 18, 34, 0.9) 0 60%, transparent 60%),
        conic-gradient(var(--success) var(--angle), rgba(255, 255, 255, 0.08) var(--angle));
      display: grid;
      place-items: center;
      padding: clamp(12px, 1.4vw, 18px);
      border: 1px solid rgba(255, 255, 255, 0.12);
    }

    .mini-progress strong {
      font-size: clamp(1.4rem, 2.5vw, 1.9rem);
      letter-spacing: 0.12em;
    }

    .mini-progress span {
      font-size: clamp(0.7rem, 1vw, 0.9rem);
      letter-spacing: 0.22em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .segment-summary {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: clamp(16px, 2vw, 32px);
      padding: clamp(18px, 2vh, 28px);
      background: var(--panel-strong);
      border-radius: 22px;
      border: 1px solid var(--outline);
    }

    .segment-card {
      display: grid;
      gap: 0.35rem;
    }

    .segment-card span {
      letter-spacing: 0.3em;
      font-size: clamp(0.75rem, 1vw, 0.95rem);
      text-transform: uppercase;
      color: var(--muted);
    }

    .segment-card strong {
      font-size: clamp(1.3rem, 2.4vw, 2rem);
      letter-spacing: 0.16em;
    }

    .segment-card p {
      margin: 0;
      font-size: clamp(0.85rem, 1.1vw, 1.1rem);
      color: rgba(244, 246, 251, 0.75);
    }

    .segment-card .countdown {
      font-size: clamp(1rem, 2vw, 1.6rem);
      color: var(--accent);
      letter-spacing: 0.18em;
    }

    .segment-card .countdown::before {
      content: 'Total Remaining';
      display: block;
      font-size: clamp(0.7rem, 0.95vw, 0.85rem);
      letter-spacing: 0.26em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 0.35rem;
    }

    .exercise-section {
      display: grid;
      gap: clamp(14px, 2vh, 24px);
    }

    .exercise-section h2 {
      margin: 0;
      font-size: clamp(1.2rem, 1.8vw, 1.9rem);
      letter-spacing: 0.3em;
      text-transform: uppercase;
    }

    .exercise-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: clamp(14px, 1.6vw, 24px);
    }

    .exercise-card {
      background: var(--panel);
      border-radius: 20px;
      border: 1px solid var(--outline);
      padding: clamp(12px, 1.4vw, 18px);
      display: grid;
      gap: clamp(10px, 1vw, 14px);
      transition: transform 180ms ease, border 180ms ease, box-shadow 180ms ease;
    }

    .exercise-card.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(79, 123, 255, 0.25);
      transform: translateY(-4px);
    }

    .video-wrapper {
      width: 100%;
      aspect-ratio: 16 / 9;
      border-radius: 14px;
      overflow: hidden;
      background:
        radial-gradient(circle at 30% 30%, rgba(79, 123, 255, 0.45), rgba(79, 123, 255, 0.12)),
        rgba(12, 22, 44, 0.85);
      display: grid;
      place-items: center;
      position: relative;
    }

    .video-wrapper iframe,
    .video-wrapper video {
      width: 100%;
      height: 100%;
      display: block;
      border: 0;
    }

    .video-wrapper video {
      object-fit: cover;
      background: #000;
    }

    .video-placeholder {
      width: 100%;
      height: 100%;
      display: grid;
      place-items: center;
      font-size: clamp(0.75rem, 0.9vw, 0.95rem);
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.8);
    }

    .exercise-card h3 {
      margin: 0;
      font-size: clamp(0.95rem, 1.2vw, 1.25rem);
      letter-spacing: 0.08em;
    }

    .exercise-card p {
      margin: 0;
      font-size: clamp(0.75rem, 1vw, 0.95rem);
      color: rgba(244, 246, 251, 0.68);
      line-height: 1.4;
    }

    footer {
      border-top: 1px solid var(--outline);
      padding: clamp(20px, 2.3vh, 32px) clamp(28px, 3vw, 56px);
      display: grid;
      grid-template-columns: 2fr 1fr;
      align-items: center;
      gap: clamp(18px, 2vw, 28px);
      background: linear-gradient(0deg, rgba(10, 18, 36, 0.9), rgba(10, 18, 36, 0.6));
    }

    .control-group {
      display: grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap: clamp(10px, 1vw, 16px);
    }

    .control-group button {
      padding: clamp(12px, 1.4vw, 16px);
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(12, 20, 38, 0.85);
      color: inherit;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      font-size: clamp(0.7rem, 0.95vw, 0.95rem);
      cursor: pointer;
      transition: transform 150ms ease, background 150ms ease, border 150ms ease;
    }

    .control-group button:hover,
    .control-group button:focus-visible {
      transform: translateY(-2px);
      background: rgba(20, 32, 60, 0.95);
      border-color: var(--accent);
      outline: none;
    }

    .control-group button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
      border-color: rgba(255, 255, 255, 0.1);
    }

    .session-summary {
      justify-self: end;
      display: grid;
      gap: 0.35rem;
      text-align: right;
    }

    .session-summary span {
      font-size: clamp(0.7rem, 0.95vw, 0.9rem);
      letter-spacing: 0.26em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .session-summary strong {
      font-size: clamp(1.1rem, 1.6vw, 1.45rem);
      letter-spacing: 0.14em;
    }

    .config-panel {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      width: min(420px, 55%);
      background: rgba(7, 12, 24, 0.92);
      border-left: 1px solid var(--outline);
      box-shadow: -24px 0 48px rgba(0, 0, 0, 0.45);
      padding: clamp(24px, 3vh, 44px);
      display: grid;
      gap: clamp(18px, 2vh, 26px);
      transform: translateX(100%);
      transition: transform 220ms ease;
    }

    .config-panel[data-open="true"] {
      transform: translateX(0);
    }

    .config-panel header {
      padding: 0;
      border: none;
      background: none;
    }

    .config-panel h2 {
      margin: 0;
      font-size: 1.35rem;
      letter-spacing: 0.24em;
      text-transform: uppercase;
    }

    .config-panel form {
      display: grid;
      gap: clamp(16px, 1.8vh, 24px);
    }

    .field {
      display: grid;
      gap: 0.35rem;
    }

    .field label {
      font-size: 0.82rem;
      letter-spacing: 0.22em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .field input {
      width: 100%;
      padding: 0.75em 1em;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(10, 16, 30, 0.92);
      color: inherit;
      font-size: 1rem;
    }

    .config-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    .config-actions button {
      padding: 0.7em 1.4em;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(14, 22, 40, 0.88);
      color: inherit;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      cursor: pointer;
      transition: transform 160ms ease, background 160ms ease;
    }

    .config-actions button:hover,
    .config-actions button:focus-visible {
      transform: translateY(-2px);
      background: rgba(24, 36, 64, 0.95);
      border-color: var(--accent);
      outline: none;
    }

    .config-actions .accent {
      background: var(--accent);
      border-color: var(--accent);
      color: #050b16;
      font-weight: 600;
    }

    .config-actions .accent:hover,
    .config-actions .accent:focus-visible {
      background: #6c93ff;
    }

    @media (max-width: 900px) {
      .exercise-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      footer {
        grid-template-columns: 1fr;
        text-align: center;
      }

      .session-summary {
        justify-self: center;
        text-align: center;
      }

      .control-group {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }

    @media (max-width: 600px) {
      .exercise-grid {
        grid-template-columns: 1fr;
      }

      .mini-progress-grid {
        grid-template-columns: 1fr;
      }

      .config-panel {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <header>
      <div class="branding">
        <h1 id="workoutTitle">RB100 Workout</h1>
        <span id="workoutTagline">30 Minute Circuit</span>
      </div>
      <button class="config-toggle" id="openConfig" type="button">⚙️ Configure</button>
    </header>

    <main>
      <section class="timer-section">
        <div class="main-timer">
          <div class="timer-ring" id="timerRing" data-phase="prepare">
            <svg class="timer-svg" viewBox="0 0 120 120" aria-hidden="true">
              <circle class="timer-track" cx="60" cy="60" r="54" />
              <circle class="timer-arc timer-arc--rest" cx="60" cy="60" r="54" id="restArc" />
              <circle class="timer-arc timer-arc--work" cx="60" cy="60" r="54" id="workArc" />
              <circle class="timer-arc timer-arc--active" cx="60" cy="60" r="54" id="activeArc" />
            </svg>
            <div class="timer-progress" id="totalProgress">
              <div class="timer-inner">
                <div class="timer-label" id="timerLabel">Prepare</div>
                <div class="timer-value" id="segmentTimeDisplay">00:10</div>
                <div class="phase-indicator" id="phaseIndicator">Get ready</div>
              </div>
            </div>
          </div>
          <div class="mini-progress-grid">
            <div class="mini-progress" id="roundProgress">
              <div class="timer-inner">
                <span>Round</span>
                <strong id="roundTracker">1 / 6</strong>
              </div>
            </div>
            <div class="mini-progress" id="cycleProgress">
              <div class="timer-inner">
                <span>Cycle</span>
                <strong id="cycleTracker">1 / 4</strong>
              </div>
            </div>
          </div>
        </div>
        <div class="segment-summary">
          <div class="segment-card">
            <span>Now</span>
            <strong id="currentAction">Prepare</strong>
            <p id="currentExercise">Dial in your form.</p>
            <div class="countdown" id="segmentCountdown">30:30</div>
          </div>
          <div class="segment-card">
            <span>Next</span>
            <strong id="nextAction">Work</strong>
            <p id="nextExercise">Kettlebell Swing is up first.</p>
          </div>
        </div>
      </section>

      <section class="exercise-section">
        <h2 id="exercisesHeading">6 Exercise Circuit</h2>
        <div class="exercise-grid" id="exerciseGrid"></div>
      </section>
    </main>

    <footer>
      <div class="control-group">
        <button id="prevExercise" type="button">⏮ Prev</button>
        <button id="startWorkout" type="button">Start</button>
        <button id="pauseWorkout" type="button">Pause</button>
        <button id="stopWorkout" type="button">Stop</button>
        <button id="resetWorkout" type="button">Reset</button>
        <button id="nextExercise" type="button">Next ⏭</button>
      </div>
      <div class="session-summary">
        <span>Session Progress</span>
        <strong id="summaryLabel">Round 1 · Cycle 1 · 30:30 left</strong>
      </div>
    </footer>

    <aside class="config-panel" id="configPanel" data-open="false">
      <header>
        <h2>Configuration</h2>
      </header>
      <form id="configForm">
        <div class="field">
          <label for="workoutSelect">Workout</label>
          <select id="workoutSelect" name="workout">
            <option value="rb100">RB100 Workout</option>
          </select>
        </div>
        <div class="field">
          <label for="prepareDuration">Prepare (seconds)</label>
          <input type="number" id="prepareDuration" name="prepareDuration" min="0" value="10" />
        </div>
        <div class="field">
          <label for="rounds">Rounds</label>
          <input type="number" id="rounds" name="rounds" min="1" value="6" />
        </div>
        <div class="field">
          <label for="cycles">Cycles</label>
          <input type="number" id="cycles" name="cycles" min="1" value="4" />
        </div>
        <div class="field">
          <label for="workDuration">Work (seconds)</label>
          <input type="number" id="workDuration" name="workDuration" min="10" value="60" />
        </div>
        <div class="field">
          <label for="restRounds">Rest Between Rounds (seconds)</label>
          <input type="number" id="restRounds" name="restRounds" min="0" value="10" />
        </div>
        <div class="field">
          <label for="restCycles">Rest Between Cycles (seconds)</label>
          <input type="number" id="restCycles" name="restCycles" min="0" value="60" />
        </div>
      </form>
      <div class="config-actions">
        <button type="button" id="closeConfig">Close</button>
        <button type="button" class="accent" id="applyDefaults">Default Times</button>
      </div>
    </aside>
  </div>

  <script>
    (function () {
      const workoutsEndpoint = 'workouts.json';
      const fallbackWorkouts = [
        {
          slug: 'rb100',
          title: 'RB100 Workout',
          tagline: '30 Minute Circuit',
          exercisesHeading: '6 Exercise Circuit',
          summary: 'Signature kettlebell conditioning set.',
          settings: {
            prepareDuration: 10,
            totalRounds: 6,
            totalCycles: 4,
            workDuration: 60,
            restBetweenRounds: 10,
            restBetweenCycles: 60
          },
          exercises: [
            {
              name: 'Kettlebell Swing',
              description: 'Explosive hip hinge to power the bell overhead and ignite the posterior chain.',
              video: 'media/burpee_standard_v1.mp4'
            },
            {
              name: 'Push-Up to T Rotation',
              description: 'Alternate a side plank reach between each rep to build rotational stability.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=dSDoVEV2298',
                title: 'Push-Up to T Rotation demo'
              }
            },
            {
              name: 'Reverse Lunge & Press',
              description: 'Step back, drop the knee, and drive overhead with the opposite arm on return.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=ZPoMxOrIeO4'
              }
            },
            {
              name: 'Renegade Row',
              description: 'Brace through the core, row the bell, and resist trunk rotation under load.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=LccyTxiUrhg'
              }
            },
            {
              name: 'V-Up Reach',
              description: 'Snap to a V-sit while touching toes and controlling the eccentric descent.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=7UVgs18Y1P4'
              }
            },
            {
              name: 'Squat Thruster',
              description: 'Sink deep into a squat and explode into a powerful overhead drive.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=L219ltL15zk'
              }
            }
          ]
        },
        {
          slug: 'ignite-intervals',
          title: 'Ignite Intervals',
          tagline: '20 Minute Power Session',
          exercisesHeading: '4 Power Moves',
          summary: 'Short, sharp metabolic finisher.',
          settings: {
            prepareDuration: 20,
            totalRounds: 4,
            totalCycles: 3,
            workDuration: 45,
            restBetweenRounds: 15,
            restBetweenCycles: 75
          },
          exercises: [
            {
              name: 'Dumbbell Snatch',
              description: 'Drive through the hips and punch overhead for total-body power.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=0P7nlJLG4rg'
              }
            },
            {
              name: 'Box Jump Rebound',
              description: 'Explode onto the box, stick the landing, and rebound with athletic control.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=2fZCk_zYbzA'
              }
            },
            {
              name: 'Battle Rope Slams',
              description: 'Alternate heavy slams to spike the heart rate and challenge core stability.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=4FJ3eYJsaGI'
              }
            },
            {
              name: 'Assault Bike Sprint',
              description: 'Crank max effort through the pedals and handles for a brutal finisher.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=1jdr8mP7LPM'
              }
            }
          ]
        },
        {
          slug: 'mobility-reset',
          title: 'Mobility Reset',
          tagline: 'Low Impact Flow',
          exercisesHeading: '6 Mobility Drills',
          summary: 'Restore and lengthen with controlled tempo.',
          settings: {
            prepareDuration: 15,
            totalRounds: 6,
            totalCycles: 2,
            workDuration: 45,
            restBetweenRounds: 15,
            restBetweenCycles: 90
          },
          exercises: [
            {
              name: 'World\'s Greatest Stretch',
              description: 'Flow between lunge, thoracic reach, and hamstring sweep to open the chain.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=XBqRr5nBKj8'
              }
            },
            {
              name: 'Thread the Needle',
              description: 'Mobilise the thoracic spine while keeping hips stacked and breathing steady.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=R5rHMyWyfKM'
              }
            },
            {
              name: 'Cossack Squat',
              description: 'Sink into lateral depth to unlock hips and ankles with control.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=_a7nK5E7EYE'
              }
            },
            {
              name: 'Dead Bug Reach',
              description: 'Brace the core while moving opposing limbs through controlled range.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=7Q1gRRtTDgY'
              }
            },
            {
              name: 'Prone Snow Angels',
              description: 'Sweep the arms overhead while squeezing the upper back and glutes.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=3jzCoqxKPlM'
              }
            },
            {
              name: '90/90 Switch',
              description: 'Rotate through internal and external hip rotation without leaning back.',
              video: {
                type: 'youtube',
                url: 'https://www.youtube.com/watch?v=9-dg9zIIebw'
              }
            }
          ]
        }
      ];

      const defaultSettings = {
        prepareDuration: 10,
        totalRounds: 6,
        totalCycles: 4,
        workDuration: 60,
        restBetweenRounds: 10,
        restBetweenCycles: 60
      };

      const config = { ...defaultSettings };

      const state = {
        schedule: [],
        totalDuration: 0,
        currentSegmentIndex: 0,
        segmentRemaining: 0,
        totalRemaining: 0,
        isRunning: false,
        isPaused: false,
        animationFrame: null,
        lastTimestamp: null
      };

      const exerciseGrid = document.getElementById('exerciseGrid');
      const form = document.getElementById('configForm');
      const applyDefaultsBtn = document.getElementById('applyDefaults');
      const configPanel = document.getElementById('configPanel');
      const openConfigBtn = document.getElementById('openConfig');
      const closeConfigBtn = document.getElementById('closeConfig');
      const workoutSelect = document.getElementById('workoutSelect');

      const elements = {
        timerRing: document.getElementById('timerRing'),
        timerLabel: document.getElementById('timerLabel'),
        phaseIndicator: document.getElementById('phaseIndicator'),
        phaseTime: document.getElementById('segmentTimeDisplay'),
        roundProgress: document.getElementById('roundProgress'),
        cycleProgress: document.getElementById('cycleProgress'),
        roundTracker: document.getElementById('roundTracker'),
        cycleTracker: document.getElementById('cycleTracker'),
        currentAction: document.getElementById('currentAction'),
        currentExercise: document.getElementById('currentExercise'),
        nextAction: document.getElementById('nextAction'),
        nextExercise: document.getElementById('nextExercise'),
        segmentCountdown: document.getElementById('segmentCountdown'),
        summaryLabel: document.getElementById('summaryLabel'),
        cards: () => Array.from(document.querySelectorAll('.exercise-card')),
        workoutTitle: document.getElementById('workoutTitle'),
        workoutTagline: document.getElementById('workoutTagline'),
        exercisesHeading: document.getElementById('exercisesHeading')
      };

      const controls = {
        start: document.getElementById('startWorkout'),
        pause: document.getElementById('pauseWorkout'),
        stop: document.getElementById('stopWorkout'),
        reset: document.getElementById('resetWorkout'),
        prev: document.getElementById('prevExercise'),
        next: document.getElementById('nextExercise')
      };

      const arcs = {
        work: document.getElementById('workArc'),
        rest: document.getElementById('restArc'),
        active: document.getElementById('activeArc')
      };

      const ARC_RADIUS = 54;
      const ARC_CIRCUMFERENCE = 2 * Math.PI * ARC_RADIUS;

      if (arcs.active) {
        arcs.active.style.strokeDasharray = `${ARC_CIRCUMFERENCE} ${ARC_CIRCUMFERENCE}`;
        arcs.active.style.strokeDashoffset = ARC_CIRCUMFERENCE;
      }

      let workouts = [];
      let exercises = [];
      let activeWorkout = null;
      let activeDefaults = { ...defaultSettings };
      let isAppReady = false;

      function sanitizeNumber(value, fallback, min) {
        const num = Number(value);
        if (Number.isFinite(num)) {
          return Math.max(min, Math.round(num));
        }
        return fallback;
      }

      function sanitizeSettings(input = {}) {
        return {
          prepareDuration: sanitizeNumber(input.prepareDuration, defaultSettings.prepareDuration, 0),
          totalRounds: sanitizeNumber(input.totalRounds, defaultSettings.totalRounds, 1),
          totalCycles: sanitizeNumber(input.totalCycles, defaultSettings.totalCycles, 1),
          workDuration: sanitizeNumber(input.workDuration, defaultSettings.workDuration, 5),
          restBetweenRounds: sanitizeNumber(input.restBetweenRounds, defaultSettings.restBetweenRounds, 0),
          restBetweenCycles: sanitizeNumber(input.restBetweenCycles, defaultSettings.restBetweenCycles, 0)
        };
      }

      function cloneSettings(settings) {
        return sanitizeSettings(settings);
      }

      function formatTime(totalSeconds) {
        const clamped = Math.max(0, Math.round(totalSeconds));
        const hours = Math.floor(clamped / 3600);
        const minutes = Math.floor((clamped % 3600) / 60);
        const seconds = clamped % 60;
        const segments = [];
        if (hours > 0) {
          segments.push(String(hours).padStart(2, '0'));
        }
        segments.push(String(minutes).padStart(2, '0'));
        segments.push(String(seconds).padStart(2, '0'));
        return segments.join(':');
      }

      function extractYouTubeId(raw) {
        if (!raw) return null;
        if (/^[\w-]{11}$/.test(raw)) {
          return raw;
        }
        try {
          const url = new URL(raw, window.location.href);
          const host = url.hostname.replace(/^www\./, '');
          if (host === 'youtu.be') {
            return url.pathname.slice(1).split('/')[0] || null;
          }
          if (host === 'youtube.com' || host === 'music.youtube.com') {
            if (url.searchParams.has('v')) {
              return url.searchParams.get('v');
            }
            const parts = url.pathname.split('/').filter(Boolean);
            const embedIndex = parts.indexOf('embed');
            if (embedIndex !== -1 && parts[embedIndex + 1]) {
              return parts[embedIndex + 1];
            }
            if (parts[0] === 'shorts' && parts[1]) {
              return parts[1];
            }
          }
        } catch (error) {
          return null;
        }
        return null;
      }

      function resolveVideoConfig(video) {
        if (!video) return null;
        if (typeof video === 'string') {
          const youtubeId = extractYouTubeId(video);
          if (youtubeId) {
            return {
              kind: 'youtube',
              src: `https://www.youtube.com/embed/${youtubeId}`,
              videoId: youtubeId
            };
          }
          return {
            kind: 'file',
            src: video
          };
        }
        if (typeof video === 'object') {
          if (video.type === 'youtube') {
            const explicitEmbed = video.embed ?? video.src;
            const youtubeId = video.id ?? extractYouTubeId(video.url ?? explicitEmbed);
            const src = explicitEmbed ?? (youtubeId ? `https://www.youtube.com/embed/${youtubeId}` : null);
            if (src) {
              return {
                kind: 'youtube',
                src,
                title: video.title ?? '',
                videoId: youtubeId ?? null
              };
            }
          }
          const src = video.src ?? video.url;
          if (src) {
            return {
              kind: 'file',
              src,
              title: video.title ?? ''
            };
          }
        }
        return null;
      }

      function withYouTubeLoop(src, videoId) {
        try {
          const url = new URL(src, window.location.href);
          url.searchParams.set('loop', '1');
          url.searchParams.set('autoplay', '1');
          url.searchParams.set('mute', '1');
          url.searchParams.set('playsinline', '1');
          const id = videoId || url.pathname.split('/').filter(Boolean).pop();
          if (id) {
            url.searchParams.set('playlist', id);
          }
          return url.toString();
        } catch (error) {
          const params = new URLSearchParams();
          params.set('loop', '1');
          params.set('autoplay', '1');
          params.set('mute', '1');
          params.set('playsinline', '1');
          if (videoId) {
            params.set('playlist', videoId);
          }
          const separator = src.includes('?') ? '&' : '?';
          return `${src}${separator}${params.toString()}`;
        }
      }

      function createVideoWrapper(videoConfig, index) {
        const wrapper = document.createElement('div');
        wrapper.className = 'video-wrapper';
        const resolved = resolveVideoConfig(videoConfig);
        if (resolved?.kind === 'youtube') {
          const iframe = document.createElement('iframe');
          iframe.src = withYouTubeLoop(resolved.src, resolved.videoId ?? null);
          iframe.title = resolved.title || `Exercise video ${index + 1}`;
          iframe.loading = 'lazy';
          iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
          iframe.referrerPolicy = 'strict-origin-when-cross-origin';
          iframe.allowFullscreen = true;
          wrapper.appendChild(iframe);
          return wrapper;
        }
        if (resolved?.kind === 'file') {
          const video = document.createElement('video');
          video.src = resolved.src;
          video.controls = true;
          video.preload = 'metadata';
          video.autoplay = true;
          video.muted = true;
          video.defaultMuted = true;
          video.loop = true;
          video.playsInline = true;
          video.setAttribute('muted', '');
          video.setAttribute('autoplay', '');
          video.setAttribute('playsinline', '');
          video.title = resolved.title || `Exercise video ${index + 1}`;
          wrapper.appendChild(video);
          return wrapper;
        }
        const placeholder = document.createElement('div');
        placeholder.className = 'video-placeholder';
        placeholder.textContent = `Video ${index + 1}`;
        wrapper.appendChild(placeholder);
        return wrapper;
      }

      function renderExerciseCards() {
        exerciseGrid.innerHTML = '';
        if (!Array.isArray(exercises) || exercises.length === 0) {
          const empty = document.createElement('p');
          empty.textContent = 'No exercises configured for this workout yet.';
          exerciseGrid.appendChild(empty);
          return;
        }
        exercises.forEach((exercise, index) => {
          const card = document.createElement('article');
          card.className = 'exercise-card';
          card.dataset.index = index;
          const videoWrapper = createVideoWrapper(exercise.video, index);
          const textWrapper = document.createElement('div');
          const heading = document.createElement('h3');
          heading.textContent = exercise.name;
          const description = document.createElement('p');
          description.textContent = exercise.description;
          textWrapper.appendChild(heading);
          textWrapper.appendChild(description);
          card.appendChild(videoWrapper);
          card.appendChild(textWrapper);
          exerciseGrid.appendChild(card);
        });
      }

      function highlightExercise(index) {
        elements.cards().forEach((card, cardIndex) => {
          card.classList.toggle('active', cardIndex === index);
        });
      }

      function updateProgressRing(element, progress) {
        if (!element) return;
        const clamped = Math.max(0, Math.min(progress, 1));
        element.style.setProperty('--angle', `${clamped * 360}deg`);
      }

      function setActiveArcProgress(remaining, total) {
        if (!arcs.active) return;
        if (!total || total <= 0) {
          arcs.active.style.strokeDashoffset = ARC_CIRCUMFERENCE;
          return;
        }
        const remainingFraction = Math.max(0, Math.min(remaining / total, 1));
        arcs.active.style.strokeDashoffset = ARC_CIRCUMFERENCE * (1 - remainingFraction);
      }

      function updateRoundArcs(workDuration, restDuration) {
        if (!arcs.work || !arcs.rest) return;
        const safeWork = Math.max(0, workDuration);
        const safeRest = Math.max(0, restDuration);
        const roundTotal = safeWork + safeRest;
        if (roundTotal <= 0) {
          clearRoundArcs();
          return;
        }
        const workRatio = Math.min(1, safeWork / roundTotal);
        const restRatio = Math.min(1, safeRest / roundTotal);
        const workLength = ARC_CIRCUMFERENCE * workRatio;
        const restLength = ARC_CIRCUMFERENCE * restRatio;
        arcs.work.style.strokeDasharray = `${workLength} ${ARC_CIRCUMFERENCE}`;
        arcs.work.style.strokeDashoffset = 0;
        arcs.work.style.opacity = workLength > 0 ? 1 : 0;
        arcs.rest.style.strokeDasharray = `${restLength} ${ARC_CIRCUMFERENCE}`;
        arcs.rest.style.strokeDashoffset = -workLength;
        arcs.rest.style.opacity = restLength > 0 ? 1 : 0;
        elements.timerRing.dataset.round = 'true';
      }

      function clearRoundArcs() {
        if (!arcs.work || !arcs.rest) return;
        elements.timerRing.dataset.round = 'false';
        arcs.work.style.strokeDasharray = `0 ${ARC_CIRCUMFERENCE}`;
        arcs.rest.style.strokeDasharray = `0 ${ARC_CIRCUMFERENCE}`;
        arcs.rest.style.strokeDashoffset = 0;
        arcs.work.style.strokeDashoffset = 0;
      }

      function buildSchedule() {
        const segments = [];
        let globalRound = 0;
        const exerciseCount = exercises.length;

        if (config.prepareDuration > 0) {
          segments.push({
            type: 'prepare',
            duration: config.prepareDuration,
            round: 0,
            cycle: 0,
            globalRound: 0,
            exerciseIndex: exerciseCount > 0 ? 0 : -1
          });
        }

        for (let cycle = 1; cycle <= config.totalCycles; cycle += 1) {
          for (let round = 1; round <= config.totalRounds; round += 1) {
            globalRound += 1;
            const exerciseIndex = exerciseCount > 0 ? (globalRound - 1) % exerciseCount : -1;
            segments.push({
              type: 'work',
              duration: config.workDuration,
              round,
              cycle,
              globalRound,
              exerciseIndex
            });

            const hasNextRoundInCycle = round < config.totalRounds;
            if (hasNextRoundInCycle && config.restBetweenRounds > 0) {
              const nextExerciseIndex = exerciseCount > 0 ? globalRound % exerciseCount : -1;
              segments.push({
                type: 'restRound',
                duration: config.restBetweenRounds,
                round,
                cycle,
                globalRound,
                exerciseIndex: nextExerciseIndex
              });
            }
          }

          const hasNextCycle = cycle < config.totalCycles && config.restBetweenCycles > 0;
          if (hasNextCycle) {
            const nextExerciseIndex = exerciseCount > 0 ? globalRound % exerciseCount : -1;
            segments.push({
              type: 'restCycle',
              duration: config.restBetweenCycles,
              round: config.totalRounds,
              cycle,
              globalRound,
              exerciseIndex: nextExerciseIndex
            });
          }
        }

        state.schedule = segments;
        state.totalDuration = segments.reduce((sum, seg) => sum + seg.duration, 0);
      }

      function setSegment(index, remaining) {
        if (state.schedule.length === 0) return;
        state.currentSegmentIndex = Math.max(0, Math.min(index, state.schedule.length - 1));
        const segment = state.schedule[state.currentSegmentIndex];
        state.segmentRemaining = remaining ?? segment.duration;
        state.totalRemaining = state.segmentRemaining;
        for (let i = state.currentSegmentIndex + 1; i < state.schedule.length; i += 1) {
          state.totalRemaining += state.schedule[i].duration;
        }
        updateUI();
      }

      function resetState() {
        buildSchedule();
        state.isRunning = false;
        state.isPaused = false;
        state.lastTimestamp = null;
        if (state.animationFrame) {
          cancelAnimationFrame(state.animationFrame);
          state.animationFrame = null;
        }
        if (state.schedule.length === 0) {
          state.totalDuration = 0;
          state.totalRemaining = 0;
          state.segmentRemaining = 0;
          state.currentSegmentIndex = 0;
          updateUI();
          return;
        }
        setSegment(0, state.schedule[0].duration);
      }

      function getExerciseName(index) {
        if (index == null || index < 0) return 'Circuit';
        return exercises[index]?.name ?? 'Circuit';
      }

      function updateUI() {
        const segment = state.schedule[state.currentSegmentIndex];
        const nextSegment = state.schedule[state.currentSegmentIndex + 1];
        const totalRounds = Math.max(1, config.totalRounds);
        const totalCycles = Math.max(1, config.totalCycles);

        const resolvedRound = segment && segment.round > 0 ? Math.min(segment.round, totalRounds) : 1;
        const resolvedCycle = segment && segment.cycle > 0 ? Math.min(segment.cycle, totalCycles) : 1;

        updateProgressRing(elements.roundProgress, totalRounds ? resolvedRound / totalRounds : 0);
        updateProgressRing(elements.cycleProgress, totalCycles ? resolvedCycle / totalCycles : 0);

        elements.roundTracker.textContent = `${resolvedRound} / ${totalRounds}`;
        elements.cycleTracker.textContent = `${resolvedCycle} / ${totalCycles}`;

        const totalRemaining = Math.max(0, state.totalRemaining);
        elements.segmentCountdown.textContent = formatTime(totalRemaining);
        elements.summaryLabel.textContent = `Round ${resolvedRound} · Cycle ${resolvedCycle} · ${formatTime(totalRemaining)} left`;

        if (!segment) {
          elements.timerRing.dataset.phase = 'complete';
          elements.timerLabel.textContent = 'Complete';
          elements.phaseIndicator.textContent = 'Workout complete';
          elements.phaseTime.textContent = '00:00';
          setActiveArcProgress(0, 1);
          clearRoundArcs();
          highlightExercise(-1);
          elements.currentAction.textContent = 'Finished';
          elements.currentExercise.textContent = 'Workout complete. Great effort!';
          elements.nextAction.textContent = '—';
          elements.nextExercise.textContent = 'Session complete';
          return;
        }

        const phaseMeta = {
          prepare: { phase: 'prepare', label: 'Prepare' },
          work: { phase: 'work', label: 'Work' },
          restRound: { phase: 'rest', label: 'Rest' },
          restCycle: { phase: 'cycleRest', label: 'Cycle Rest' }
        }[segment.type] ?? { phase: 'prepare', label: 'Prepare' };

        const paused = state.isPaused && state.isRunning;
        elements.timerRing.dataset.phase = paused ? 'paused' : phaseMeta.phase;
        elements.timerLabel.textContent = paused ? 'Paused' : phaseMeta.label;

        const segmentDuration = segment.duration || 0;
        elements.phaseTime.textContent = formatTime(state.segmentRemaining);
        setActiveArcProgress(state.segmentRemaining, segmentDuration);

        const isRoundPhase = segment.type === 'work' || segment.type === 'restRound';
        if (isRoundPhase) {
          const upcomingRest =
            segment.type === 'work'
              ? (segment.round < config.totalRounds ? config.restBetweenRounds : 0)
              : segment.duration;
          updateRoundArcs(config.workDuration, upcomingRest);
        } else {
          clearRoundArcs();
        }

        let currentExerciseText = '';
        let highlightIndex = segment.exerciseIndex ?? -1;

        if (segment.type === 'prepare') {
          const firstWork = state.schedule.find((entry) => entry.type === 'work');
          const firstName = firstWork ? getExerciseName(firstWork.exerciseIndex) : 'first exercise';
          currentExerciseText = firstWork ? `First up: ${firstName}` : 'Dial in your form.';
          highlightIndex = firstWork ? firstWork.exerciseIndex : -1;
        } else if (segment.type === 'work') {
          currentExerciseText = `Go hard: ${getExerciseName(highlightIndex)}`;
        } else if (segment.type === 'restRound') {
          const nextWork = state.schedule.slice(state.currentSegmentIndex + 1).find((entry) => entry.type === 'work');
          const nextName = nextWork ? getExerciseName(nextWork.exerciseIndex) : getExerciseName(segment.exerciseIndex);
          currentExerciseText = nextWork ? `Recover before ${nextName}` : 'Take a quick breather.';
          highlightIndex = nextWork ? nextWork.exerciseIndex : segment.exerciseIndex ?? -1;
        } else if (segment.type === 'restCycle') {
          const targetCycle = Math.min(segment.cycle + 1, config.totalCycles);
          currentExerciseText = segment.cycle < config.totalCycles ? `Reset for cycle ${targetCycle}` : 'Cool down and celebrate.';
          highlightIndex = -1;
        } else {
          currentExerciseText = 'Stay focused and breathe.';
        }

        if (paused) {
          elements.phaseIndicator.textContent = 'Paused';
          elements.currentAction.textContent = 'Paused';
          elements.currentExercise.textContent = currentExerciseText;
        } else {
          elements.phaseIndicator.textContent = phaseMeta.label;
          elements.currentAction.textContent = phaseMeta.label;
          elements.currentExercise.textContent = currentExerciseText;
        }

        highlightExercise(highlightIndex);

        if (nextSegment) {
          const nextLabel = {
            prepare: 'Prepare',
            work: 'Work',
            restRound: 'Rest',
            restCycle: 'Cycle Rest'
          }[nextSegment.type] ?? 'Prepare';
          elements.nextAction.textContent = nextLabel;
          if (nextSegment.type === 'work') {
            elements.nextExercise.textContent = getExerciseName(nextSegment.exerciseIndex);
          } else if (nextSegment.type === 'restRound') {
            elements.nextExercise.textContent = 'Recovery window';
          } else if (nextSegment.type === 'restCycle') {
            const targetCycle = Math.min(nextSegment.cycle + 1, config.totalCycles);
            elements.nextExercise.textContent = nextSegment.cycle < config.totalCycles ? `Reset for cycle ${targetCycle}` : 'Cool down';
          } else {
            elements.nextExercise.textContent = 'Pre-start countdown';
          }
        } else {
          elements.nextAction.textContent = 'Finish';
          elements.nextExercise.textContent = 'Final push to complete.';
        }

        const initialDuration = state.schedule[0]?.duration ?? 0;
        const atBeginning =
          state.currentSegmentIndex === 0 &&
          Math.abs(state.segmentRemaining - initialDuration) < 0.5 &&
          !state.isRunning;
        const atEnd =
          state.currentSegmentIndex >= state.schedule.length - 1 &&
          !state.isRunning &&
          state.totalRemaining < 0.5;

        controls.start.disabled = state.isRunning && !state.isPaused;
        controls.pause.disabled = !state.isRunning;
        controls.pause.textContent = state.isPaused ? 'Resume' : 'Pause';
        controls.stop.disabled = atBeginning && !state.isRunning;
        controls.reset.disabled = atBeginning && !state.isRunning;
        controls.prev.disabled =
          state.schedule.length === 0 ||
          findNextWork(state.currentSegmentIndex, -1) === state.currentSegmentIndex;
        controls.next.disabled =
          state.schedule.length === 0 ||
          findNextWork(state.currentSegmentIndex, 1) === state.currentSegmentIndex ||
          atEnd;
      }

      function advance(delta) {
        let remainingDelta = delta;
        while (remainingDelta > 0 && state.schedule[state.currentSegmentIndex]) {
          if (state.segmentRemaining > remainingDelta) {
            state.segmentRemaining -= remainingDelta;
            state.totalRemaining = Math.max(0, state.totalRemaining - remainingDelta);
            remainingDelta = 0;
          } else {
            remainingDelta -= state.segmentRemaining;
            state.totalRemaining = Math.max(0, state.totalRemaining - state.segmentRemaining);
            const nextIndex = state.currentSegmentIndex + 1;
            if (nextIndex >= state.schedule.length) {
              state.segmentRemaining = 0;
              state.currentSegmentIndex = nextIndex;
              state.isRunning = false;
              if (state.animationFrame) {
                cancelAnimationFrame(state.animationFrame);
                state.animationFrame = null;
              }
              break;
            }
            state.currentSegmentIndex = nextIndex;
            state.segmentRemaining = state.schedule[state.currentSegmentIndex].duration;
          }
        }
        updateUI();
      }

      function tick(timestamp) {
        if (!state.isRunning || state.isPaused) return;
        if (state.lastTimestamp == null) {
          state.lastTimestamp = timestamp;
        }
        const delta = (timestamp - state.lastTimestamp) / 1000;
        state.lastTimestamp = timestamp;
        advance(delta);
        if (state.isRunning && !state.isPaused) {
          state.animationFrame = requestAnimationFrame(tick);
        }
      }

      function startTimer() {
        if (state.schedule.length === 0 || state.currentSegmentIndex >= state.schedule.length) {
          resetState();
        }
        if (!state.isRunning) {
          state.isRunning = true;
          state.isPaused = false;
          state.lastTimestamp = null;
          state.animationFrame = requestAnimationFrame(tick);
        } else if (state.isPaused) {
          state.isPaused = false;
          state.lastTimestamp = null;
          state.animationFrame = requestAnimationFrame(tick);
        }
        updateUI();
      }

      function pauseTimer() {
        if (!state.isRunning) return;
        state.isPaused = !state.isPaused;
        if (!state.isPaused) {
          state.lastTimestamp = null;
          state.animationFrame = requestAnimationFrame(tick);
        }
        updateUI();
      }

      function stopTimer() {
        state.isRunning = false;
        state.isPaused = false;
        if (state.animationFrame) {
          cancelAnimationFrame(state.animationFrame);
          state.animationFrame = null;
        }
        resetState();
      }

      function resetTimer() {
        if (state.animationFrame) {
          cancelAnimationFrame(state.animationFrame);
          state.animationFrame = null;
        }
        state.isRunning = false;
        state.isPaused = false;
        setSegment(0, state.schedule[0]?.duration ?? 0);
        updateUI();
      }

      function findNextWork(fromIndex, direction) {
        if (state.schedule.length === 0) return fromIndex;
        if (direction > 0) {
          for (let i = fromIndex + 1; i < state.schedule.length; i += 1) {
            if (state.schedule[i].type === 'work') return i;
          }
          return state.schedule.length - 1;
        }
        for (let i = fromIndex - 1; i >= 0; i -= 1) {
          if (state.schedule[i].type === 'work') return i;
        }
        return 0;
      }

      function skip(direction) {
        if (state.schedule.length === 0) return;
        const nextWorkIndex = findNextWork(state.currentSegmentIndex, direction);
        if (nextWorkIndex === state.currentSegmentIndex) {
          return;
        }
        state.currentSegmentIndex = nextWorkIndex;
        state.segmentRemaining = state.schedule[nextWorkIndex].duration;
        state.totalRemaining = state.segmentRemaining;
        for (let i = nextWorkIndex + 1; i < state.schedule.length; i += 1) {
          state.totalRemaining += state.schedule[i].duration;
        }
        state.lastTimestamp = null;
        updateUI();
      }

      controls.start.addEventListener('click', startTimer);
      controls.pause.addEventListener('click', pauseTimer);
      controls.stop.addEventListener('click', stopTimer);
      controls.reset.addEventListener('click', resetTimer);
      controls.next.addEventListener('click', () => skip(1));
      controls.prev.addEventListener('click', () => skip(-1));

      openConfigBtn.addEventListener('click', () => {
        configPanel.dataset.open = 'true';
      });

      closeConfigBtn.addEventListener('click', () => {
        configPanel.dataset.open = 'false';
      });

      applyDefaultsBtn.addEventListener('click', () => {
        if (!activeDefaults) return;
        setFormValuesFromSettings(activeDefaults);
        updateConfigFromForm();
      });

      function setFormValuesFromSettings(settings) {
        form.prepareDuration.value = settings.prepareDuration;
        form.rounds.value = settings.totalRounds;
        form.cycles.value = settings.totalCycles;
        form.workDuration.value = settings.workDuration;
        form.restRounds.value = settings.restBetweenRounds;
        form.restCycles.value = settings.restBetweenCycles;
      }

      function syncFormFromConfig() {
        setFormValuesFromSettings(config);
      }

      function applySettingsToConfig(settings) {
        const clean = sanitizeSettings(settings);
        Object.assign(config, clean);
        return clean;
      }

      function updateConfigFromForm() {
        const nextSettings = {
          prepareDuration: form.prepareDuration.value,
          totalRounds: form.rounds.value,
          totalCycles: form.cycles.value,
          workDuration: form.workDuration.value,
          restBetweenRounds: form.restRounds.value,
          restBetweenCycles: form.restCycles.value
        };
        applySettingsToConfig(nextSettings);
        if (isAppReady) {
          resetState();
          setWorkoutInUrl(activeWorkout?.slug);
        }
      }

      form.addEventListener('input', updateConfigFromForm);

      function normalizeWorkouts(rawList) {
        if (!Array.isArray(rawList)) return [];
        return rawList
          .map((item) => {
            if (!item || !item.slug) return null;
            const slug = String(item.slug).toLowerCase();
            const settings = sanitizeSettings(item.settings || {});
            return {
              slug,
              title: item.title || slug.replace(/[-_]/g, ' ').replace(/\b\w/g, (char) => char.toUpperCase()),
              tagline: item.tagline || '',
              exercisesHeading: item.exercisesHeading || 'Exercise Circuit',
              summary: item.summary || '',
              settings,
              exercises: Array.isArray(item.exercises) ? item.exercises : []
            };
          })
          .filter(Boolean);
      }

      async function loadWorkouts() {
        try {
          const response = await fetch(workoutsEndpoint, { cache: 'no-store' });
          if (!response.ok) {
            throw new Error(`Failed to load workouts: ${response.status}`);
          }
          const payload = await response.json();
          const list = Array.isArray(payload) ? payload : Array.isArray(payload.workouts) ? payload.workouts : [];
          const normalized = normalizeWorkouts(list);
          if (normalized.length > 0) {
            workouts = normalized;
            return;
          }
        } catch (error) {
          console.warn('Falling back to bundled workouts.', error);
        }
        workouts = normalizeWorkouts(fallbackWorkouts);
      }

      function populateWorkoutSelect() {
        workoutSelect.innerHTML = '';
        workouts.forEach((workout) => {
          const option = document.createElement('option');
          option.value = workout.slug;
          option.textContent = workout.title;
          workoutSelect.appendChild(option);
        });
      }

      workoutSelect.addEventListener('change', (event) => {
        const slug = event.target.value;
        const workout = workouts.find((candidate) => candidate.slug === slug);
        if (workout) {
          selectWorkout(workout);
        }
      });

      function setWorkoutInUrl(slug) {
        if (!slug) return;
        const url = new URL(window.location.href);
        url.searchParams.set('workout', slug);
        const query = url.searchParams.toString();
        const newUrl = `${url.pathname}${query ? `?${query}` : ''}`;
        window.history.replaceState({}, '', newUrl);
      }

      function getWorkoutSlugFromUrl() {
        const url = new URL(window.location.href);
        const slugFromQuery = url.searchParams.get('workout');
        if (slugFromQuery) return slugFromQuery.toLowerCase();
        const hash = url.hash.replace(/^#/, '');
        return hash ? hash.toLowerCase() : null;
      }

      function updateBranding(workout) {
        if (elements.workoutTitle) {
          elements.workoutTitle.textContent = workout.title;
        }
        if (elements.workoutTagline) {
          elements.workoutTagline.textContent = workout.tagline || '';
        }
        if (elements.exercisesHeading) {
          elements.exercisesHeading.textContent = workout.exercisesHeading || 'Exercise Circuit';
        }
        document.title = workout.title;
      }

      function selectWorkout(workout) {
        if (!workout) return;
        if (state.animationFrame) {
          cancelAnimationFrame(state.animationFrame);
          state.animationFrame = null;
        }
        state.isRunning = false;
        state.isPaused = false;
        isAppReady = false;

        activeWorkout = workout;
        activeDefaults = cloneSettings(workout.settings);
        exercises = Array.isArray(workout.exercises) ? workout.exercises.slice() : [];
        applySettingsToConfig(activeDefaults);
        syncFormFromConfig();
        renderExerciseCards();
        updateBranding(workout);
        workoutSelect.value = workout.slug;
        resetState();
        highlightExercise(-1);
        setWorkoutInUrl(workout.slug);
        isAppReady = true;
      }

      function pickInitialWorkout() {
        const slug = getWorkoutSlugFromUrl();
        if (slug) {
          const match = workouts.find((workout) => workout.slug === slug);
          if (match) {
            return match;
          }
        }
        return workouts[0] ?? null;
      }

      async function initialize() {
        await loadWorkouts();
        populateWorkoutSelect();
        const initialWorkout = pickInitialWorkout();
        if (initialWorkout) {
          selectWorkout(initialWorkout);
        } else {
          renderExerciseCards();
          resetState();
        }
      }

      initialize();
    })();
  </script>

</body>
</html>
